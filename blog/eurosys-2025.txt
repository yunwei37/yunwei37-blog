1:"$Sreact.fragment"
2:I[1478,["874","static/chunks/874-8edb22cc7428423c.js","650","static/chunks/650-5bb235cd9bfca45d.js","177","static/chunks/app/layout-66df3ac28fcfbced.js"],"ThemeProviders"]
3:I[4091,["874","static/chunks/874-8edb22cc7428423c.js","650","static/chunks/650-5bb235cd9bfca45d.js","177","static/chunks/app/layout-66df3ac28fcfbced.js"],"default"]
4:I[9243,["874","static/chunks/874-8edb22cc7428423c.js","650","static/chunks/650-5bb235cd9bfca45d.js","177","static/chunks/app/layout-66df3ac28fcfbced.js"],""]
5:I[7392,["874","static/chunks/874-8edb22cc7428423c.js","650","static/chunks/650-5bb235cd9bfca45d.js","177","static/chunks/app/layout-66df3ac28fcfbced.js"],"KBarSearchProvider"]
6:I[6874,["874","static/chunks/874-8edb22cc7428423c.js","63","static/chunks/63-d245e42a784ca56d.js","909","static/chunks/app/blog/%5B...slug%5D/page-1ed2702378ba9d6b.js"],""]
e:I[8393,[],""]
:HL["/_next/static/media/36966cca54120369-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/4ac7c0f872b74ee7.css","style"]
:HL["/_next/static/css/a06d7e24bf9a7d93.css","style"]
:HL["/_next/static/css/7246298b30c42979.css","style"]
0:{"P":null,"b":"MYXrWUjg0HELsl6zLYF_6","p":"","c":["","blog","eurosys-2025"],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","eurosys-2025","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/4ac7c0f872b74ee7.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/a06d7e24bf9a7d93.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en-us","className":"__variable_dd5b2f scroll-smooth","suppressHydrationWarning":true,"children":[["$","link",null,{"rel":"apple-touch-icon","sizes":"76x76","href":"/static/favicons/apple-touch-icon.png"}],["$","link",null,{"rel":"icon","type":"image/svg+xml","href":"/static/favicons/favicon.svg"}],["$","link",null,{"rel":"icon","type":"image/png","sizes":"32x32","href":"/static/favicons/favicon-32x32.png"}],["$","link",null,{"rel":"icon","type":"image/png","sizes":"16x16","href":"/static/favicons/favicon-16x16.png"}],["$","link",null,{"rel":"manifest","href":"/static/favicons/site.webmanifest"}],["$","link",null,{"rel":"mask-icon","href":"/static/favicons/safari-pinned-tab.svg","color":"#5bbad5"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#000000"}],["$","meta",null,{"name":"theme-color","media":"(prefers-color-scheme: light)","content":"#fff"}],["$","meta",null,{"name":"theme-color","media":"(prefers-color-scheme: dark)","content":"#000"}],["$","link",null,{"rel":"alternate","type":"application/rss+xml","href":"/feed.xml"}],["$","body",null,{"className":"pl-[calc(100vw-100%)] text-black antialiased dark:text-white min-h-screen","children":["$","$L2",null,{"children":[["$","$L3",null,{}],["$undefined","$undefined","$undefined",["$","$L4",null,{"async":true,"defer":true,"src":"https://analytics.umami.is/script.js"}],"$undefined","$undefined"],["$","div",null,{"className":"min-h-screen flex flex-col justify-center py-8","children":["$","div",null,{"className":"content-glass mx-auto w-full max-w-5xl px-4 sm:px-6 xl:px-8 py-8","children":["$","$L5",null,{"kbarConfig":{"searchDocumentsPath":"/search.json"},"children":[["$","header",null,{"className":"flex items-center w-full justify-between py-6 border-b border-gray-200/30 dark:border-gray-700/30","children":[["$","$L6",null,{"className":"break-words","href":"/","aria-label":"yunwei37","children":["$","div",null,{"className":"flex items-center","children":[["$","div",null,{"className":"mr-3","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":40,"height":40,"fill":"none","children":[["$","defs",null,{"children":[["$","linearGradient",null,{"id":"logo_svg__a","x1":"0%","x2":"100%","y1":"0%","y2":"100%","children":[["$","stop",null,{"offset":"0%","style":{"stopColor":"#3b82f6","stopOpacity":1}}],["$","stop",null,{"offset":"100%","style":{"stopColor":"#06b6d4","stopOpacity":1}}]]}],["$","linearGradient",null,{"id":"logo_svg__b","x1":"0%","x2":"100%","y1":"0%","y2":"100%","children":[["$","stop",null,{"offset":"0%","style":{"stopColor":"#8b5cf6","stopOpacity":1}}],["$","stop",null,{"offset":"100%","style":{"stopColor":"#3b82f6","stopOpacity":1}}]]}]]}],["$","circle",null,{"cx":20,"cy":20,"r":18,"fill":"url(#logo_svg__a)","opacity":0.1}],["$","path",null,{"fill":"url(#logo_svg__a)","d":"m12 8 6 10v10h4V18l6-10h-4l-4 6-4-6Z"}],["$","path",null,{"fill":"url(#logo_svg__b)","d":"m8 24 4 8 4-8 4 8 4-8h8v4h-6l-4 8-4-8-4 8-4-8H8Z","opacity":0.8}],["$","circle",null,{"cx":32,"cy":12,"r":2,"fill":"url(#logo_svg__b)"}],["$","circle",null,{"cx":8,"cy":12,"r":1.5,"fill":"url(#logo_svg__a)","opacity":0.6}]]}]}],["$","div",null,{"className":"hidden text-2xl font-bold sm:block hover:text-primary-600 dark:hover:text-primary-400 transition-colors","children":"yunwei37"}]]}]}],["$","div",null,{"className":"flex items-center space-x-4","children":[["$","div",null,{"className":"no-scrollbar hidden items-center space-x-2 sm:flex","children":[["$","$L6","Blog",{"className":"px-3 py-2 rounded-lg transition-all duration-200 font-medium hover:text-primary-600 dark:hover:text-primary-400","href":"/blog","children":"Blog"}],["$","$L6","Docs",{"className":"px-3 py-2 rounded-lg transition-all duration-200 font-medium hover:text-primary-600 dark:hover:text-primary-400","href":"/docs","children":"Docs"}],["$","$L6","Tags",{"className":"px-3 py-2 rounded-lg transition-all duration-200 font-medium hover:text-primary-600 dark:hover:text-primary-400","href":"/tags","children":"Tags"}],["$","$L6","About",{"className":"px-3 py-2 rounded-lg transition-all duration-200 font-medium hover:text-primary-600 dark:hover:text-primary-400","href":"/about","children":"About"}]]}],"$L7"]}]]}],"$L8","$L9"]}]}]}]]}]}]]}]]}],{"children":["blog","$La",{"children":[["slug","eurosys-2025","c"],"$Lb",{"children":["__PAGE__","$Lc",{},null,false]},null,false]},null,false]},null,false],"$Ld",false]],"m":"$undefined","G":["$e",[]],"s":false,"S":true}
f:I[4159,["874","static/chunks/874-8edb22cc7428423c.js","650","static/chunks/650-5bb235cd9bfca45d.js","177","static/chunks/app/layout-66df3ac28fcfbced.js"],"KBarButton"]
10:I[1762,["874","static/chunks/874-8edb22cc7428423c.js","650","static/chunks/650-5bb235cd9bfca45d.js","177","static/chunks/app/layout-66df3ac28fcfbced.js"],"default"]
11:I[7298,["874","static/chunks/874-8edb22cc7428423c.js","650","static/chunks/650-5bb235cd9bfca45d.js","177","static/chunks/app/layout-66df3ac28fcfbced.js"],"default"]
12:I[7555,[],""]
13:I[1295,[],""]
1e:I[9665,[],"OutletBoundary"]
20:I[4911,[],"AsyncMetadataOutlet"]
22:I[9665,[],"ViewportBoundary"]
24:I[9665,[],"MetadataBoundary"]
25:"$Sreact.suspense"
7:["$","div",null,{"className":"flex items-center space-x-2","children":[["$","$Lf",null,{"aria-label":"Search","className":"p-2 rounded-lg transition-all duration-200","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","fill":"none","viewBox":"0 0 24 24","strokeWidth":1.5,"stroke":"currentColor","className":"h-6 w-6 hover:text-primary-600 dark:hover:text-primary-400 transition-colors","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","d":"M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"}]}]}],["$","$L10",null,{}],["$","$L11",null,{}]]}]
8:["$","main",null,{"className":"py-6","children":["$","$L12",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L13",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","div",null,{"className":"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6","children":[["$","div",null,{"className":"space-x-2 pt-6 pb-8 md:space-y-5","children":["$","h1",null,{"className":"text-6xl leading-9 font-extrabold tracking-tight md:border-r-2 md:px-6 md:text-8xl md:leading-14","children":"404"}]}],["$","div",null,{"className":"max-w-md","children":[["$","p",null,{"className":"mb-4 text-xl leading-normal font-bold md:text-2xl","children":"Sorry we couldn't find this page."}],["$","p",null,{"className":"mb-8","children":"But dont worry, you can find plenty of other things on our homepage."}],["$","$L6",null,{"className":"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm leading-5 font-medium text-white shadow-xs transition-colors duration-150 hover:bg-blue-700 focus:outline-hidden dark:hover:bg-blue-500","href":"/","children":"Back to homepage"}]]}]]}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]
9:["$","footer",null,{"className":"border-t border-gray-200/30 dark:border-gray-700/30 pt-8","children":["$","div",null,{"className":"flex flex-col items-center space-y-6","children":[["$","div",null,{"className":"flex flex-wrap justify-center gap-4","children":[["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"mailto:yunwei356@gmail.com","children":[["$","span",null,{"className":"sr-only","children":"mail"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 20 20","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"Mail"}],["$","path",null,{"d":"M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"}],["$","path",null,{"d":"M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"}]]}]]}],["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://github.com/yunwei37","children":[["$","span",null,{"className":"sr-only","children":"github"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"GitHub"}],["$","path",null,{"d":"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"}]]}]]}],["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://facebook.com","children":[["$","span",null,{"className":"sr-only","children":"facebook"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"Facebook"}],["$","path",null,{"d":"M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"}]]}]]}],["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://youtube.com","children":[["$","span",null,{"className":"sr-only","children":"youtube"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"Youtube"}],["$","path",null,{"d":"M23.499 6.203a3.008 3.008 0 00-2.089-2.089c-1.87-.501-9.4-.501-9.4-.501s-7.509-.01-9.399.501a3.008 3.008 0 00-2.088 2.09A31.258 31.26 0 000 12.01a31.258 31.26 0 00.523 5.785 3.008 3.008 0 002.088 2.089c1.869.502 9.4.502 9.4.502s7.508 0 9.399-.502a3.008 3.008 0 002.089-2.09 31.258 31.26 0 00.5-5.784 31.258 31.26 0 00-.5-5.808zm-13.891 9.4V8.407l6.266 3.604z"}]]}]]}],"$L14","$L15","$L16","$L17","$L18","$L19","$L1a"]}],"$L1b","$L1c"]}]}]
a:["$","$1","c",{"children":[null,["$","$L12",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L13",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}]
b:["$","$1","c",{"children":[null,["$","$L12",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L13",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}]
c:["$","$1","c",{"children":["$L1d",[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/7246298b30c42979.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$L1e",null,{"children":["$L1f",["$","$L20",null,{"promise":"$@21"}]]}]]}]
d:["$","$1","h",{"children":[null,[["$","$L22",null,{"children":"$L23"}],["$","meta",null,{"name":"next-size-adjust","content":""}]],["$","$L24",null,{"children":["$","div",null,{"hidden":true,"children":["$","$25",null,{"fallback":null,"children":"$L26"}]}]}]]}]
14:["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://www.linkedin.com/in/yusheng-zheng-611920280","children":[["$","span",null,{"className":"sr-only","children":"linkedin"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"Linkedin"}],["$","path",null,{"d":"M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"}]]}]]}]
15:null
16:["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://bsky.app/","children":[["$","span",null,{"className":"sr-only","children":"bluesky"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"Bluesky"}],["$","path",null,{"d":"M12 10.8c-1.087-2.114-4.046-6.053-6.798-7.995C2.566.944 1.561 1.266.902 1.565C.139 1.908 0 3.08 0 3.768c0 .69.378 5.65.624 6.479c.815 2.736 3.713 3.66 6.383 3.364q.204-.03.415-.056q-.207.033-.415.056c-3.912.58-7.387 2.005-2.83 7.078c5.013 5.19 6.87-1.113 7.823-4.308c.953 3.195 2.05 9.271 7.733 4.308c4.267-4.308 1.172-6.498-2.74-7.078a9 9 0 0 1-.415-.056q.21.026.415.056c2.67.297 5.568-.628 6.383-3.364c.246-.828.624-5.79.624-6.478c0-.69-.139-1.861-.902-2.206c-.659-.298-1.664-.62-4.3 1.24C16.046 4.748 13.087 8.687 12 10.8"}]]}]]}]
17:["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://x.com/yunwei37","children":[["$","span",null,{"className":"sr-only","children":"x"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"X"}],["$","path",null,{"d":"M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"}]]}]]}]
27:T69f,M12 0C8.74 0 8.333.015 7.053.072 5.775.132 4.905.333 4.14.63c-.789.306-1.459.717-2.126 1.384S.935 3.35.63 4.14C.333 4.905.131 5.775.072 7.053.012 8.333 0 8.74 0 12s.015 3.667.072 4.947c.06 1.277.261 2.148.558 2.913.306.788.717 1.459 1.384 2.126.667.666 1.336 1.079 2.126 1.384.766.296 1.636.499 2.913.558C8.333 23.988 8.74 24 12 24s3.667-.015 4.947-.072c1.277-.06 2.148-.262 2.913-.558.788-.306 1.459-.718 2.126-1.384.666-.667 1.079-1.335 1.384-2.126.296-.765.499-1.636.558-2.913.06-1.28.072-1.687.072-4.947s-.015-3.667-.072-4.947c-.06-1.277-.262-2.149-.558-2.913-.306-.789-.718-1.459-1.384-2.126C21.319 1.347 20.651.935 19.86.63c-.765-.297-1.636-.499-2.913-.558C15.667.012 15.26 0 12 0zm0 2.16c3.203 0 3.585.016 4.85.071 1.17.055 1.805.249 2.227.415.562.217.96.477 1.382.896.419.42.679.819.896 1.381.164.422.36 1.057.413 2.227.057 1.266.07 1.646.07 4.85s-.015 3.585-.074 4.85c-.061 1.17-.256 1.805-.421 2.227-.224.562-.479.96-.899 1.382-.419.419-.824.679-1.38.896-.42.164-1.065.36-2.235.413-1.274.057-1.649.07-4.859.07-3.211 0-3.586-.015-4.859-.074-1.171-.061-1.816-.256-2.236-.421-.569-.224-.96-.479-1.379-.899-.421-.419-.69-.824-.9-1.38-.165-.42-.359-1.065-.42-2.235-.045-1.26-.061-1.649-.061-4.844 0-3.196.016-3.586.061-4.861.061-1.17.255-1.814.42-2.234.21-.57.479-.96.9-1.381.419-.419.81-.689 1.379-.898.42-.166 1.051-.361 2.221-.421 1.275-.045 1.65-.06 4.859-.06l.045.03zm0 3.678c-3.405 0-6.162 2.76-6.162 6.162 0 3.405 2.76 6.162 6.162 6.162 3.405 0 6.162-2.76 6.162-6.162 0-3.405-2.76-6.162-6.162-6.162zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4zm7.846-10.405c0 .795-.646 1.44-1.44 1.44-.795 0-1.44-.646-1.44-1.44 0-.794.646-1.439 1.44-1.439.793-.001 1.44.645 1.44 1.439z18:["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://www.instagram.com","children":[["$","span",null,{"className":"sr-only","children":"instagram"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"Instagram"}],["$","path",null,{"d":"$27"}]]}]]}]
28:T498,M12.186 24h-.007c-3.581-.024-6.334-1.205-8.184-3.509C2.35 18.44 1.5 15.586 1.472 12.01v-.017c.03-3.579.879-6.43 2.525-8.482C5.845 1.205 8.6.024 12.18 0h.014c2.746.02 5.043.725 6.826 2.098 1.677 1.29 2.858 3.13 3.509 5.467l-2.04.569c-1.104-3.96-3.898-5.984-8.304-6.015-2.91.022-5.11.936-6.54 2.717C4.307 6.504 3.616 8.914 3.589 12c.027 3.086.718 5.496 2.057 7.164 1.43 1.783 3.631 2.698 6.54 2.717 2.623-.02 4.358-.631 5.8-2.045 1.647-1.613 1.618-3.593 1.09-4.798-.31-.71-.873-1.3-1.634-1.75-.192 1.352-.622 2.446-1.284 3.272-.886 1.102-2.14 1.704-3.73 1.79-1.202.065-2.361-.218-3.259-.801-1.063-.689-1.685-1.74-1.752-2.964-.065-1.19.408-2.285 1.33-3.082.88-.76 2.119-1.207 3.583-1.291a13.853 13.853 0 0 1 3.02.142c-.126-.742-.375-1.332-.75-1.757-.513-.586-1.308-.883-2.359-.89h-.029c-.844 0-1.992.232-2.721 1.32L7.734 7.847c.98-1.454 2.568-2.256 4.478-2.256h.044c3.194.02 5.097 1.975 5.287 5.388.108.046.216.094.321.142 1.49.7 2.58 1.761 3.154 3.07.797 1.82.871 4.79-1.548 7.158-1.85 1.81-4.094 2.628-7.277 2.65Zm1.003-11.69c-.242 0-.487.007-.739.021-1.836.103-2.98.946-2.916 2.143.067 1.256 1.452 1.839 2.784 1.767 1.224-.065 2.818-.543 3.086-3.71a10.5 10.5 0 0 0-2.215-.221z19:["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://www.threads.net","children":[["$","span",null,{"className":"sr-only","children":"threads"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"Threads"}],["$","path",null,{"d":"$28"}]]}]]}]
1a:["$","a",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://medium.com","children":[["$","span",null,{"className":"sr-only","children":"medium"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"hover:text-primary-500 dark:hover:text-primary-400 fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","title",null,{"children":"Medium"}],["$","path",null,{"d":"M13.54 12a6.8 6.8 0 01-6.77 6.82A6.8 6.8 0 010 12a6.8 6.8 0 016.77-6.82A6.8 6.8 0 0113.54 12zM20.96 12c0 3.54-1.51 6.42-3.38 6.42-1.87 0-3.39-2.88-3.39-6.42s1.52-6.42 3.39-6.42 3.38 2.88 3.38 6.42M24 12c0 3.17-.53 5.75-1.19 5.75-.66 0-1.19-2.58-1.19-5.75s.53-5.75 1.19-5.75C23.47 6.25 24 8.83 24 12z"}]]}]]}]
1b:["$","div",null,{"className":"flex space-x-2 text-sm opacity-80","children":[["$","div",null,{"children":"Yusheng Zheng"}],["$","div",null,{"children":" • "}],["$","div",null,{"children":"© 2026"}],["$","div",null,{"children":" • "}],["$","$L6",null,{"className":"hover:text-primary-500 transition-colors","href":"/","children":"云微的胡思乱想"}]]}]
1c:["$","div",null,{"className":"text-sm opacity-60","children":["$","a",null,{"className":"hover:text-primary-500 transition-colors","target":"_blank","rel":"noopener noreferrer","href":"https://github.com/timlrx/tailwind-nextjs-starter-blog","children":"Tailwind Nextjs Theme"}]}]
29:I[1839,["874","static/chunks/874-8edb22cc7428423c.js","63","static/chunks/63-d245e42a784ca56d.js","909","static/chunks/app/blog/%5B...slug%5D/page-1ed2702378ba9d6b.js"],"default"]
2a:I[3063,["874","static/chunks/874-8edb22cc7428423c.js","63","static/chunks/63-d245e42a784ca56d.js","909","static/chunks/app/blog/%5B...slug%5D/page-1ed2702378ba9d6b.js"],"Image"]
1d:[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"EuroSys 2025 Paper Summaries and Analysis\",\"datePublished\":\"2025-04-25T16:00:00.000Z\",\"dateModified\":\"2025-04-25T16:00:00.000Z\",\"image\":\"/static/images/twitter-card.png\",\"url\":\"https://www.yunwei37.com/blog/eurosys-2025\",\"author\":[{\"@type\":\"Person\",\"name\":\"Yusheng Zheng (云微)\"}]}"}}],["$","section",null,{"className":"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0","children":[["$","$L29",null,{}],["$","article",null,{"className":"content-glass p-8","children":["$","div",null,{"className":"xl:divide-y xl:divide-gray-200/30 xl:dark:divide-gray-700/30","children":[["$","header",null,{"className":"pt-6 xl:pb-6","children":["$","div",null,{"className":"space-y-4 text-center","children":[["$","dl",null,{"className":"space-y-4","children":["$","div",null,{"children":[["$","dt",null,{"className":"sr-only","children":"Published on"}],["$","dd",null,{"className":"text-base leading-6 font-medium text-gray-600 dark:text-gray-300","children":["$","time",null,{"dateTime":"2025-04-25T16:00:00.000Z","children":"Friday, April 25, 2025"}]}]]}]}],["$","div",null,{"children":["$","h1",null,{"className":"text-3xl leading-9 font-extrabold tracking-tight sm:text-4xl sm:leading-10 md:text-5xl md:leading-14","children":"EuroSys 2025 Paper Summaries and Analysis"}]}]]}]}],["$","div",null,{"className":"grid-rows-[auto_1fr] divide-y divide-gray-200/30 pb-8 xl:grid xl:grid-cols-4 xl:gap-x-8 xl:divide-y-0 dark:divide-gray-700/30","children":[["$","dl",null,{"className":"pt-6 pb-10 xl:border-b xl:border-gray-200/30 xl:pt-11 xl:dark:border-gray-700/30","children":[["$","dt",null,{"className":"sr-only","children":"Authors"}],["$","dd",null,{"children":["$","ul",null,{"className":"flex flex-wrap justify-center gap-4 sm:space-x-12 xl:block xl:space-y-6 xl:space-x-0","children":[["$","li","Yusheng Zheng (云微)",{"className":"flex items-center space-x-3 glass p-4 rounded-xl","children":[["$","$L2a",null,{"src":"/static/images/avatar.png","width":38,"height":38,"alt":"avatar","className":"h-10 w-10 rounded-full"}],["$","dl",null,{"className":"text-sm leading-5 font-medium whitespace-nowrap","children":[["$","dt",null,{"className":"sr-only","children":"Name"}],["$","dd",null,{"className":"text-gray-900 dark:text-gray-100","children":"Yusheng Zheng (云微)"}],["$","dt",null,{"className":"sr-only","children":"Twitter"}],["$","dd",null,{"children":["$","a",null,{"className":"text-primary-600 hover:text-primary-700 dark:text-primary-400 dark:hover:text-primary-300 transition-colors","target":"_blank","rel":"noopener noreferrer","href":"https://twitter.com/yunwei37","children":"@yunwei37"}]}]]}]]}]]}]}]]}],["$","div",null,{"className":"divide-y divide-gray-200/30 xl:col-span-3 xl:row-span-2 xl:pb-0 dark:divide-gray-700/30","children":[["$","div",null,{"className":"prose dark:prose-invert max-w-none pt-10 pb-8 text-gray-700 dark:text-gray-200","children":[["$","h1",null,{"className":"content-header","id":"eurosys-2025-paper-summaries-and-analysis","children":[["$","a",null,{"className":"break-words","href":"#eurosys-2025-paper-summaries-and-analysis","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"EuroSys 2025 Paper Summaries and Analysis"]}],["$","p",null,{"children":"This post offers a detailed examination of papers accepted at EuroSys 2025, one of the premier conferences in computer systems research. I've analyzed over 40 papers spanning AI systems, cloud computing, networking, storage, and security to identify emerging trends, technical breakthroughs, and industry implications. For researchers and practitioners alike, this analysis provides a roadmap of where systems research is heading—highlighting both solved problems and remaining challenges. Each paper is summarized with its key contributions and practical relevance, followed by a synthesis of overarching themes and future research directions."}],"$L2b","$L2c","$L2d","$L2e","$L2f","$L30","$L31","$L32","$L33","$L34","$L35","$L36","$L37","$L38","$L39","$L3a","$L3b","$L3c","$L3d","$L3e","$L3f","$L40","$L41","$L42","$L43","$L44","$L45","$L46","$L47","$L48","$L49","$L4a","$L4b","$L4c","$L4d"]}],"$L4e","$L4f"]}],"$L50"]}]]}]}]]}]]
8e:I[1449,["874","static/chunks/874-8edb22cc7428423c.js","63","static/chunks/63-d245e42a784ca56d.js","909","static/chunks/app/blog/%5B...slug%5D/page-1ed2702378ba9d6b.js"],"default"]
2b:["$","h3",null,{"className":"content-header","id":"emerging-hot-directions","children":[["$","a",null,{"className":"break-words","href":"#emerging-hot-directions","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Emerging Hot Directions"]}]
2c:["$","p",null,{"children":["This EuroSys 2025 collection underscores ",["$","strong",null,{"children":"systems for AI/ML"}]," as a dominant theme. Many papers address the challenges of training and serving large models – from distributed training optimizations (Mist, MEPipe, HybridFlow) to efficient inference serving (HCache, Pensieve, CacheBlend, T-MAC, SpInfer, DeltaZip). The trend is towards ",["$","strong",null,{"children":"bespoke systems support for LLMs"}],": co-designing scheduling, memory management, and compression techniques specifically for giant models. We also see systems using ",["$","em",null,{"children":"AI techniques within themselves"}]," (Deep RL for VM scheduling, learned indexes like LOFT). This cross-pollination (using AI to build systems and vice-versa) is a clear trajectory for future work."]}]
2d:["$","p",null,{"children":["Another hot direction is ",["$","strong",null,{"children":"resource disaggregation and tiering"}]," – multiple papers (Deft, Chrono, PET, Adios) tackle the fundamental shifts needed when memory or storage is disaggregated across the network or split into tiers. The community is preparing for a world of ",["$","strong",null,{"children":"CXL-attached memory and pooled resources"}],", ensuring performance doesn’t crumble even as hardware becomes more distributed. Techniques like meticulous hotness tracking (Chrono) and yield-based page fault handling (Adios) illustrate a broad effort to rethink OS services for microsecond-scale networks."]}]
2e:["$","p",null,{"children":[["$","strong",null,{"children":"Networking and data center communication"}]," remains vibrant, with new congestion control paradigms (Introspective CC, Fork, virtual priorities) and verification tools (Atlas, Marlin) – a response to ever-larger and more complex networks. Notably, there’s emphasis on ",["$","em",null,{"children":"predictability and verification"}],": ensuring consistent performance (Introspective CC) and using formal or automated checks (Atlas) to avoid outages. This reflects industry’s need for reliability at scale."]}]
2f:["$","p",null,{"children":[["$","strong",null,{"children":"Security and isolation"}]," innovations are present throughout: from CKI’s secure containers to Achilles’s TEE consensus and many eBPF-related insights. There’s a clear trend of making high-performance systems ",["$","strong",null,{"children":"secure by design"}],". Hardware features (Intel PKS, SGX) are being creatively used to reduce the overhead of security (CKI, RAKIS), indicating a shift where security is no longer an afterthought but integrated into the system’s core architecture."]}]
30:["$","h3",null,{"className":"content-header","id":"unsolved-problems-and-gaps","children":[["$","a",null,{"className":"break-words","href":"#unsolved-problems-and-gaps","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Unsolved Problems and Gaps"]}]
31:["$","p",null,{"children":["Despite progress, unsolved challenges emerge. One gap is ",["$","strong",null,{"children":"managing complexity"}],": systems like HybridFlow or Pensieve achieve impressive results but at the cost of intricate designs (multi-controller RLHF, multi-tier caching). Taming this complexity – perhaps via better abstractions or automation – is still an open issue. Similarly, ",["$","em",null,{"children":"developer-friendly"}]," tooling is a gap: e.g., writing correct high-performance eBPF is still hard (as “unstable foundations” suggests), and programming disaggregated memory or tiered storage remains complex. We have point solutions (like eNetSTL or visual kernel tracing), but a general easing of programmability in these domains is needed."]}]
32:["$","p",null,{"children":["Another unsolved problem is ",["$","strong",null,{"children":"comprehensive performance isolation"}]," in shared environments. Various papers (Faro, GPU multiplexing, SpotHedge) tackle isolation in one dimension (CPU, GPU, spot VMs), yet the problem is far from fully solved. A general framework that guarantees SLOs across all resources and levels (CPU, memory, network, storage) remains elusive – current solutions are still domain-specific. This is a ripe area for future cross-domain schedulers or isolation techniques that can handle multi-resource contention holistically."]}]
33:["$","p",null,{"children":[["$","strong",null,{"children":"Verification and correctness for modern systems"}]," also present gaps. While Atlas and Seal make strides in network and kernel verification, respectively, we lack equivalent tools for, say, ",["$","em",null,{"children":"ML systems correctness"}]," (ensuring distributed training converges correctly under failures) or ",["$","em",null,{"children":"disaggregated systems correctness"}],". As systems become more complex (with hardware acceleration, distributed components, etc.), verifying their correctness (both functional and performance) is increasingly challenging. The proceedings hint at verification (Seal, Atlas), but this is likely to grow into a bigger research thrust."]}]
34:["$","h3",null,{"className":"content-header","id":"surprising-and-novel-insights","children":[["$","a",null,{"className":"break-words","href":"#surprising-and-novel-insights","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Surprising and Novel Insights"]}]
35:["$","p",null,{"children":["One surprising theme is ",["$","strong",null,{"children":"proactiveness"}]," – several works flip the usual reactive approach on its head. PET proactively demotes memory, Adios reverts to yields instead of busy-wait, Faro ",["$","em",null,{"children":"intentionally sloppifies"}]," utilities for agility, HybridFlow mixes controllers rather than sticking to one paradigm. This willingness to ",["$","em",null,{"children":"relax traditional strictness (in consistency, precision, or roles)"}]," in order to gain performance or simplicity is a notable mindset shift. The success of these systems suggests that carefully relaxing constraints (with feedback or hardware support to back it) can yield big wins – a possibly counterintuitive insight for system designers accustomed to rigid correctness or structure."]}]
36:["$","p",null,{"children":["Another notable challenge mentioned is the ",["$","strong",null,{"children":"“last mile” problem"}]," in various guises: e.g., the gap between an LFS and PM (Scatter Logging), or between user expectations of container security and reality (CKI’s motivation). These last-mile issues often require interdisciplinary thinking (combining hardware and software techniques, or merging algorithms with systems). The community is identifying these and addressing them case-by-case; an open question is how to systematically close such gaps in general."]}]
37:["$","h3",null,{"className":"content-header","id":"trends-in-methodology-and-infrastructure","children":[["$","a",null,{"className":"break-words","href":"#trends-in-methodology-and-infrastructure","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Trends in Methodology and Infrastructure"]}]
38:["$","p",null,{"children":["Across the papers, there’s a clear trend of ",["$","strong",null,{"children":"co-designing with hardware features"}],": be it using sparse tensor cores (Samoyeds, SpInfer), new CPU instructions (CKI with PKS, T-MAC with lookup tables), or specialized NIC capabilities (Pegasus, virtual priority CC). The methodology is to ",["$","em",null,{"children":"embrace hardware constraints or features"}]," rather than abstract them away. This indicates future researchers will likely need even deeper understanding of hardware – and perhaps collaborate more with hardware designers – as we venture into ML accelerators, CXL fabrics, and new non-volatile memories. We also see a trend of building ",["$","strong",null,{"children":"unified frameworks"}]," (AlloyStack for workflows, NeuStream bridging streams and ML, Pegasus unifying local/remote comms). This suggests a move away from siloed designs: instead of having one system for X and another for Y with costly glue between, researchers aim to provide a single solution that covers both seamlessly. This reduces overhead and complexity – a win for both performance and manageability."]}]
39:["$","p",null,{"children":["Another methodological trend is ",["$","strong",null,{"children":"extensive use of data-driven optimization"}],": Many systems use profiling, ML, or rigorous analysis of traces (e.g., Faro’s prediction, CAPSys’s contention modeling, LOFT’s adaptive learned models, SpotHedge’s statistical approach to instance termination). The classic static heuristics are being replaced by adaptive, data-informed decisions. This aligns with the industry trend of telemetry-driven autoscaling and AIops – systems that can observe and tune themselves in a feedback loop."]}]
3a:["$","h3",null,{"className":"content-header","id":"infrastructure-and-hardware-assumptions-shifts","children":[["$","a",null,{"className":"break-words","href":"#infrastructure-and-hardware-assumptions-shifts","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Infrastructure and Hardware Assumptions Shifts"]}]
3b:["$","p",null,{"children":["The proceedings reflect some shifting assumptions. Where once one might assume all memory is local and homogeneous, now designs assume memory might be remote or tiered (and plan accordingly). There’s an implicit assumption in many papers that ",["$","strong",null,{"children":"latency is a multi-scale problem"}]," – nanoseconds (on-chip) to microseconds (RDMA/NVMe) to milliseconds (network/storage). Systems are being built to operate effectively at microsecond granularity, which was previously the domain of specialized HPC, but now is mainstream with NVMe and RDMA. This requires rethinking blocking vs spinning (Adios) and OS scheduling (unithreads)."]}]
3c:["$","p",null,{"children":["Hardware-wise, it’s evident that GPUs and accelerators are ",["$","strong",null,{"children":"first-class citizens"}]," in system design now. Many works treat GPU scheduling, sharing, and GPU-specific ops (sparsity cores, etc.) as a core part of the system, not an add-on. The presence of ",["$","em",null,{"children":"two-level scheduling"}]," (GPU within CPU scheduling) and handling of GPU memory as a scarce resource (in LLM serving caches, etc.) shows an assumption that heterogeneous computing is here to stay. Future infrastructures will likely consider CPU, GPU, and other accelerators in a unified resource model – a challenge raised by these works."]}]
3d:["$","h3",null,{"className":"content-header","id":"advice-for-future-research","children":[["$","a",null,{"className":"break-words","href":"#advice-for-future-research","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Advice for Future Research"]}]
3e:["$","p",null,{"children":["Researchers should note the momentum in ",["$","strong",null,{"children":"cross-stack optimization"}]," – breakthroughs often came from working across traditional boundaries (e.g., using hardware features in OS (CKI), or combining networking and OS design (Pegasus), or ML and DB techniques (learned indexes)). The ability to traverse multiple layers (hardware, OS, runtime, application) to find global optima is increasingly valuable. Following the ",["$","strong",null,{"children":"data-driven approach"}]," is also fruitful: systems that leverage real patterns (Faro’s traces, Seal’s mining of patches, BINGO’s analysis of graph changes) tend to achieve robust improvements by tailoring to reality, not worst-case alone."]}]
3f:["$","p",null,{"children":["Another takeaway is the emphasis on ",["$","strong",null,{"children":["efficiency ",["$","em",null,{"children":"and"}]," correctness/security together"]}],". Many papers manage to improve performance while ",["$","em",null,{"children":"also"}]," improving isolation or correctness (CKI doesn’t slow down containers much, Achilles improves BFT efficiency and security, PET improves memory use without performance loss, etc.). This suggests future work can’t sacrifice one for the other easily – the bar is to achieve both. Research into new hardware (like secure enclaves, or programmable NICs) combined with clever system software can yield such win-wins."]}]
40:["$","p",null,{"children":["Finally, a notable shift is the focus on ",["$","strong",null,{"children":"systems scalability in non-traditional dimensions"}],": not just more nodes, but more models (DeltaZip for many models), more workflows (AlloyStack), more eBPF programs (eNetSTL). The trend is to support ",["$","strong",null,{"children":"“more of everything”"}]," – and do so automatically and robustly. Future researchers can build on this by designing systems that gracefully scale in problem dimensionality (models, functions, rules, etc.) using techniques like compression, caching, or parallelism, as exemplified in these papers."]}]
41:["$","p",null,{"children":["Overall, EuroSys 2025’s papers illustrate a landscape where ",["$","strong",null,{"children":"AI-centric systems, disaggregated architectures, and secure, autonomous management"}]," are at the forefront. Embracing these trends and addressing the open challenges – from simplifying complex systems to verifying their behavior – will define the next milestones for systems research. Each category of work here provides stepping stones for future exploration, whether it’s scaling ever-larger AI models, making cloud infrastructure more efficient and reliable, or leveraging new hardware to its fullest potential. The clear message is that ",["$","strong",null,{"children":"holistic, cross-layer design"}]," and ",["$","strong",null,{"children":"proactive, intelligent adaptation"}]," are key to building the next generation of computer systems."]}]
42:["$","h2",null,{"className":"content-header","id":"ai-and-machine-learning-systems","children":[["$","a",null,{"className":"break-words","href":"#ai-and-machine-learning-systems","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"AI and Machine Learning Systems"]}]
43:["$","ul",null,{"children":[["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Mist: Efficient Distributed Training of Large Language Models via Memory-Parallelism Co-Optimization"}]," – ",["$","em",null,{"children":"Zhanda Zhu, Christina Giannoula, Muralidhar Andoorveedu, Qidong Su, Karttikeya Mangalam, Bojian Zheng, Gennady Pekhimenko."}]," This paper introduces ",["$","strong",null,{"children":"Mist"}],", a distributed training system that ",["$","strong",null,{"children":"co-optimizes memory reduction techniques and parallelism strategies"}]," for large language model (LLM) training. Mist orchestrates data, tensor, and pipeline parallelism together with memory-saving optimizations (like activation checkpointing and offloading) through ",["$","em",null,{"children":"overlap-centric scheduling"}]," and symbolic performance modeling. By hierarchically tuning for workload imbalance, Mist finds efficient configurations automatically, achieving up to ",["$","em",null,{"children":"1.73× faster training than Megatron-LM"}]," (manual baseline) and ",["$","em",null,{"children":"up to 2.04× speedup over prior automation (Aceso)"}],". ",["$","em",null,{"children":"Industry Relevance:"}]," Mist addresses the cost of training giant models by enabling organizations to train LLMs on limited hardware more efficiently, which is crucial for industry labs seeking to ",["$","strong",null,{"children":"reduce GPU memory and time requirements"}]," in LLM training."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"MEPipe: Democratizing LLM Training with Memory-Efficient Slice-Level Pipeline Scheduling on Cost-Effective Accelerators"}]," – ",["$","em",null,{"children":"Zhenbo Sun, Shengqi Chen, Yuanwei Wang, Jian Sha, Guanyu Feng, Wenguang Chen."}]," ",["$","strong",null,{"children":"MEPipe"}]," proposes a novel ",["$","em",null,{"children":"“slice-level” pipeline parallelism"}]," to train large models on affordable GPUs (e.g. RTX 4090) that have limited memory. It ",["$","strong",null,{"children":"partitions each training batch into finer slices"}]," along the sequence length, carefully scheduling forward and backward passes to overlap computation and reduce memory usage. MEPipe’s design minimizes activation memory and avoids costly inter-GPU communication by using fine-grained weight gradient computation and sequence-level pipelining. In experiments on LLaMA models, MEPipe attains ",["$","em",null,{"children":"up to 1.68× training speedup (1.35× on average)"}]," on 4090 GPU clusters and significantly improves cost-effectiveness (2.5× more cost-efficient than A100-based clusters). ",["$","em",null,{"children":"Industry Relevance:"}]," MEPipe helps “",["$","strong",null,{"children":"democratize"}],"” LLM training by allowing companies or groups with ",["$","strong",null,{"children":"cheaper GPU hardware"}]," to train large models efficiently, lowering the barrier for startups or academia to experiment with big models."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"HybridFlow: A Flexible and Efficient RLHF Framework"}]," – ",["$","em",null,{"children":"Guangming Sheng, Chi Zhang, Zilingfeng Ye, Xibin Wu, Wang Zhang, Ru Zhang, Yanghua Peng, Haibin Lin, Chuan Wu."}]," This work targets ",["$","strong",null,{"children":"Reinforcement Learning from Human Feedback (RLHF)"}]," pipelines used to align LLMs. ",["$","strong",null,{"children":"HybridFlow"}]," introduces a hybrid control paradigm that combines a single centralized controller with multiple distributed controllers for different phases of RLHF. It provides hierarchical APIs to decouple the complex workflow (which includes distributed policy training and generation steps) and an optimized “3D-HybridEngine” for model resharding between training and inference phases. By ","$L51"," and enabling flexible execution of RLHF’s interwoven tasks, HybridFlow achieves ","$L52"," on various RLHF algorithms compared to existing frameworks. ","$L53"," RLHF is crucial for fine-tuning AI assistants (as done at OpenAI, Anthropic, etc.). HybridFlow’s efficient orchestration can ","$L54"," for large models, benefitting industry teams that need to frequently retrain models with human feedback."]}]}],"$L55","$L56","$L57","$L58","$L59","$L5a","$L5b","$L5c","$L5d"]}]
44:["$","h2",null,{"className":"content-header","id":"cloud-and-systems-management","children":[["$","a",null,{"className":"break-words","href":"#cloud-and-systems-management","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Cloud and Systems Management"]}]
45:["$","ul",null,{"children":[["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"A House United Within Itself: SLO-Awareness for On-Premises Containerized ML Inference Clusters via Faro"}]," – ",["$","em",null,{"children":"Beomyeol Jeon, Chen Wang, Diana Arroyo, Alaa Youssef, Indranil Gupta."}]," This paper presents ",["$","strong",null,{"children":"Faro"}],", a system to manage a ",["$","strong",null,{"children":"private ML inference cluster"}]," (on-premises cloud) under dynamic loads while meeting latency ",["$","em",null,{"children":"Service Level Objectives (SLOs)"}],". Faro takes high-level latency SLOs per application and converts them into ",["$","em",null,{"children":"utility functions"}],", then ",["$","strong",null,{"children":"“sloppifies”"}]," these utilities (i.e. relaxes precision) for tractable optimization. It uses probabilistic workload prediction and continuously reallocates resources across models to maximize total utility or fairness. Uniquely, Faro deliberately trades some precision for agility – simplifying models of cluster behavior to react quickly to load spikes. In a Kubernetes + Ray Serve testbed, Faro cut SLO violations by ",["$","strong",null,{"children":"2.3×–23×"}]," compared to state-of-the-art systems. ",["$","em",null,{"children":"Industry Relevance:"}]," Many enterprises run ",["$","strong",null,{"children":"multiple ML services on shared clusters"}],". Faro’s approach helps them ",["$","strong",null,{"children":"maintain QoS (e.g. 99th percentile latency)"}]," for all models even as demand fluctuates, which is critical for user-facing applications and efficient cluster utilization in industry."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"SpotHedge: Serving AI Models on Spot Instances"}]," – ",["$","em",null,{"children":"Ziming Mao, Tian Xia, Zhanghao Wu, Wei-Lin Chiang, Tyler Griggs, Romil Bhardwaj, Zongheng Yang, Scott Shenker, Ion Stoica."}]," SpotHedge enables reliable ML inference on ",["$","strong",null,{"children":"spot cloud instances"}]," (cheap VMs that can be preempted). It likely employs a redundancy and hedging strategy: launching model replicas on multiple spot VMs in different pools and cleverly ",["$","em",null,{"children":"overlapping execution"}]," so that if one instance is reclaimed, another can take over without missing deadlines. The system probably uses predictive techniques to decide when to proactively migrate or copy state. By hedging across spot markets, SpotHedge achieves on-par tail latency with on-demand instances, but at much lower cost. ",["$","em",null,{"children":"Industry Relevance:"}]," This system is valuable for cost-sensitive deployment of online services (e.g. a startup serving an AI API). It allows use of ",["$","strong",null,{"children":"preemptible VMs (70-90% cheaper)"}]," without sacrificing reliability, thereby lowering operating costs for model serving in the cloud."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Towards VM Rescheduling Optimization Through Deep Reinforcement Learning"}]," – ",["$","em",null,{"children":"Xianzhong Ding, Yunkai Zhang, Binbin Chen, Donghao Ying, Tieying Zhang, Jianjun Chen, Lei Zhang, Alberto Cerpa, Wan Du."}]," This work treats the ",["$","strong",null,{"children":"VM rescheduling problem"}]," (periodically re-packing VMs to hosts to mitigate hotspots and fragmentation) as a learning task. It proposes a Deep Reinforcement Learning agent that observes cluster state and decides which VMs to migrate where, aiming to improve overall resource utilization and performance. Through training on simulations or historical data, the DRL agent learns strategies to reduce contention (like CPU or memory hotspots) better than heuristic policies. ","$L5e"," Large cloud operators regularly perform ","$L5f"," and load balancing. A DRL-based rescheduler could adapt to complex patterns and achieve higher efficiency (fewer servers, less throttling) than static rules, potentially saving costs in data centers."]}]}],"$L60","$L61","$L62","$L63","$L64","$L65","$L66","$L67","$L68"]}]
46:["$","h2",null,{"className":"content-header","id":"networking-and-distributed-systems","children":[["$","a",null,{"className":"break-words","href":"#networking-and-distributed-systems","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Networking and Distributed Systems"]}]
47:["$","ul",null,{"children":[["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Introspective Congestion Control for Consistent High Performance"}]," – ",["$","em",null,{"children":"Wanchun Jiang, Haoyang Li, Jia Wu, Kai Wang, Fengyuan Ren, Jianxin Wang."}]," This paper proposes a congestion control (CC) algorithm that ",["$","strong",null,{"children":"adapts to network variations by introspecting on its own performance"}],". Traditional CC (like TCP variants) can suffer in consistency – e.g., throughput fluctuates or drops under certain patterns. The “introspective” approach likely monitors metrics like latency variation or send/ack patterns to detect suboptimal behavior (bufferbloat, incipient congestion) and then adjusts its sending strategy or parameters. The goal is to maintain more stable high throughput with low latency. ",["$","em",null,{"children":"Industry Relevance:"}]," Large-scale services (video streaming, data replication, etc.) require ",["$","strong",null,{"children":"predictable network performance"}],". A smarter CC that self-tunes in real time could provide ",["$","strong",null,{"children":"smoother throughput and low tail latency"}]," on varied networks (data centers, 5G, Internet), benefiting cloud providers and CDN operators with more efficient network utilization."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Fork: A Dual Congestion Control Loop for Small and Large Flows in Datacenters"}]," – ",["$","em",null,{"children":"Yuan Liu, Wenxin Li, Yulong Li, Lide Suo, Xuan Gao, Xin Xie, Sheng Chen, Ziqi Fan, Wenyu Qu, Guyue Liu."}]," Fork addresses the classic problem of co-existence of ",["$","strong",null,{"children":"mice and elephant flows"}]," in datacenters. It implements ",["$","em",null,{"children":"two coupled control loops"}],": one optimized for short flows (minimizing latency) and one for long flows (maximizing throughput). Small flows get preferential quick-start and aggressive completion, while large flows use a steadier AIMD or rate-based control. The “dual loop” likely means the algorithm can distinguish flow sizes early (via hints or initial packet trends) and apply appropriate CC behavior, possibly switching mode as flows grow. ",["$","em",null,{"children":"Industry Relevance:"}]," This directly benefits datacenter networking – by ",["$","strong",null,{"children":"reducing tail latency for RPCs and bursty short transfers"}]," without hurting bulk flow throughput, Fork can improve application-level performance (e.g., web search or microservices) in cloud data centers where mixed traffic is common."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Enabling Virtual Priority in Data Center Congestion Control"}]," – ",["$","em",null,{"children":"Zhaochen Zhang, Feiyang Xue, Keqiang He, Zhimeng Yin, Gianni Antichi, Jiaqi Gao, Yizhi Wang, Rui Ning, Haixin Nan, Xu Zhang, Peirui Cao, Xiaoliang Wang, Wanchun Dou, Guihai Chen, Chen Tian."}]," This work introduces the concept of ",["$","strong",null,{"children":"virtual priority"}]," levels in congestion control, aiming to enforce priority handling (like PFC / priority flow control) via software CC algorithms rather than relying purely on network hardware queues. It likely modifies the congestion feedback signals (e.g., marking packets with different priorities or using multi-bit ECN) so that higher-priority flows experience less queuing when contending with lower-priority flows, without needing strict priority scheduling in switches. ","$L69"," Many data center applications would benefit from ","$L6a"," (e.g., storage traffic vs. best-effort analytics). Implementing it at the CC layer means ","$L6b"," (no need for complex switch config). This could translate to more predictable performance for high-priority services in multi-tenant or multi-application clusters."]}]}],"$L6c","$L6d","$L6e","$L6f","$L70","$L71","$L72","$L73","$L74","$L75","$L76","$L77"]}]
48:["$","h2",null,{"className":"content-header","id":"storage-and-memory-systems","children":[["$","a",null,{"className":"break-words","href":"#storage-and-memory-systems","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Storage and Memory Systems"]}]
49:["$","ul",null,{"children":[["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Deft: A Scalable Tree Index for Disaggregated Memory"}]," – ",["$","em",null,{"children":"Jing Wang, Qing Wang, Yuhao Zhang, Jiwu Shu."}]," Deft is a custom indexing data structure designed for ",["$","strong",null,{"children":"memory disaggregation architectures"}],", where RAM is pooled and accessed over the network. It provides a scalable tree index (likely a B⁺-tree variant) that minimizes remote memory accesses and latency. Deft probably clusters tree nodes and uses pointer-free techniques or approximate positioning to reduce indirections, making lookups and updates efficient despite the high latency of disaggregated memory. It also likely handles partial caching of the tree in local memory to accelerate operations. ",["$","em",null,{"children":"Industry Relevance:"}]," In disaggregated data centers (e.g. with CXL attached memory or rack-scale memory pools), standard indexes can incur too many network fetches. Deft enables ",["$","strong",null,{"children":"fast data lookup in a network-attached memory scenario"}],", which is useful for distributed databases or in-memory caches that span multiple machines, a scenario emerging in modern cloud designs."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"LOFT: A Lock-free and Adaptive Learned Index with High Scalability for Dynamic Workloads"}]," – ",["$","em",null,{"children":"Yuxuan Mo, Yu Hua."}]," LOFT combines two trends: ",["$","strong",null,{"children":"learned indexes"}]," (which use machine learning models to map keys to positions in a sorted array, as an alternative to B-trees) and ",["$","strong",null,{"children":"lock-free concurrency"}],". It presents a highly scalable index structure that adapts to workload changes (insertions, deletions, shifting key distributions) by adjusting the learned models on the fly, and it does so with a lock-free algorithm to avoid contention. This yields an index that is both fast (taking advantage of ML for search) and concurrent (many threads can perform operations without blocking each other). ",["$","em",null,{"children":"Industry Relevance:"}]," High-throughput key-value stores and databases can benefit from ",["$","strong",null,{"children":"learned indexes to save space and potentially speed up queries"}],". LOFT’s contributions mean these benefits can be realized even under heavy, dynamic workloads (common in real-time analytics or social network feeds) and on multicore servers without contention – improving performance of storage systems in industry scenarios."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Chrono: Meticulous Hotness Measurement and Flexible Page Migration for Memory Tiering"}]," – ",["$","em",null,{"children":"Zhenlin Qi, Shengan Zheng, Ying Huang, Yifeng Hui, Bowen Zhang, Linpeng Huang, Hong Mei."}]," Chrono improves OS/hypervisor management for systems with ",["$","strong",null,{"children":"tiered memory"}]," (fast DRAM and slower memory like NVM or SSD used as pseudo-RAM). It provides ",["$","em",null,{"children":"fine-grained hotness tracking"}],": rather than coarse counters or infrequent scans, Chrono meticulously measures page access frequency with high resolution to identify truly “hot” and “cold” pages. It also introduces a flexible migration policy that avoids hardwired thresholds – possibly using a dynamic or ML-based policy to decide when to promote/demote pages between tiers. By aligning hotness measurement with the performance characteristics of devices (e.g. NVM latency), Chrono ensures that promotions/demotions yield real performance gains. This avoids thrashing and underutilization seen in prior systems with rigid rules. ","$L78"," As data centers incorporate ","$L79"," alongside DRAM, Chrono’s approach allows them to ","$L7a"," (keep hot pages in DRAM) with minimal overhead. This improves application performance (database caching, in-memory analytics) and enables larger memory capacity at lower cost by safely using slower tiers."]}]}],"$L7b","$L7c","$L7d","$L7e","$L7f","$L80","$L81","$L82","$L83","$L84","$L85"]}]
4a:["$","h2",null,{"className":"content-header","id":"security-and-reliability","children":[["$","a",null,{"className":"break-words","href":"#security-and-reliability","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Security and Reliability"]}]
4b:["$","ul",null,{"children":[["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"CKI (Container Kernel Isolation): A Hardware-Software Co-Design for Efficient Secure Containers"}]," – ",["$","em",null,{"children":"Jiacheng Shi, Yang Yu, Jinyu Gu, Yubin Xia."}]," This work introduces ",["$","strong",null,{"children":"CKI"}],", which adds a new privilege level and monitor to achieve strong isolation of container kernels from the host, without the overhead of full VMs. By leveraging Intel’s memory protection keys (PKS) hardware, CKI runs each container’s guest kernel in a de-privileged mode and uses a thin Kernel Separation Monitor (KSM) to mediate privileged operations. This means even if a container’s kernel is compromised, it cannot harm the host or other containers (unlike normal containers), achieving security comparable to VMs. Importantly, CKI avoids the costly parts of virtualization: it has ",["$","strong",null,{"children":"fast PKS-based switches"}]," and eliminates certain side-channel mitigations on those transitions, cutting overhead by hundreds of cycles. In bare-metal cloud tests, CKI improved memory-heavy application latencies by up to ",["$","em",null,{"children":"18–47%"}]," vs KVM and even more in nested scenarios. In nested (VM-in-VM) setups, CKI got ",["$","em",null,{"children":"6.8× higher throughput"}]," for I/O apps compared to traditional approaches. ",["$","em",null,{"children":"Industry Relevance:"}]," CKI provides ",["$","strong",null,{"children":"VM-level security with container-level efficiency"}],". This is a breakthrough for multi-tenant cloud services: cloud providers could offer “secure containers” where tenants get strong isolation without the performance hit of full VMs, combining the best of both worlds and potentially replacing many VM use-cases."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Erebor: A Drop-In Sandbox Solution for Private Data Processing in Untrusted Confidential Virtual Machines"}]," – ",["$","em",null,{"children":"Chuqi Zhang, Rahul Priolkar, Yuancheng Jiang, Yuan Xiao, Mona Vij, Zhenkai Liang, Adil Ahmad."}]," Erebor is a sandboxing mechanism to safely process sensitive data in a cloud VM that ",["$","strong",null,{"children":"the user does not fully trust"}]," (even with confidential VMs, the cloud provider could be semi-trusted). It likely uses a combination of hardware enclaves and isolated execution to ensure that specific data or code runs in a contained environment inside the VM. “Drop-in” suggests it doesn’t require modifying the guest OS or apps much – it might intercept syscalls or use hypervisor tricks to compartmentalize workloads on the fly. This allows, for instance, running a third-party analytics function on your private data in a VM, while making sure that function can’t leak data out. ",["$","em",null,{"children":"Industry Relevance:"}]," As confidential computing becomes popular, ",["$","strong",null,{"children":"fine-grained sandboxing"}]," inside those environments is needed (for multi-stage pipelines, or protecting against insider threats). Erebor could help companies safely utilize cloud VMs for sensitive workloads by adding an ",["$","em",null,{"children":"extra layer of defense"}]," around data processing modules, even if the VM OS or some libraries are not fully trusted."]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Seal: Towards Diverse Specification Inference for Linux Interfaces from Security Patches"}]," – ",["$","em",null,{"children":"Wei Chen, Bowen Zhang, Chengpeng Wang, Wensheng Tang, Charles Zhang."}]," Seal automatically infers ","$L86"," for Linux kernel interfaces by analyzing historical ","$L87",". The insight is that many security fixes essentially add a check or a missing step (e.g., locking, input validation) – from these, one can deduce what ","$L88"," have been done originally. Seal likely mines a corpus of kernel patches, clustering them to identify implicit rules like “function X must be called after Y” or “check pointer Z before use”. By diversifying sources (different bugs), it infers broader specs than a single buggy example. These inferred specs can then be used to detect other bugs or ensure new code complies. ","$L89"," The Linux kernel is huge and developers may unknowingly violate rules, causing vulnerabilities. Seal’s inferred specs provide ","$L8a"," for kernel developers and static analysis tools. This helps OS vendors (Google, RedHat, etc.) catch bugs early and improve kernel security by learning from past mistakes."]}]}],"$L8b","$L8c","$L8d"]}]
4c:["$","h2",null,{"className":"content-header","id":"references","children":[["$","a",null,{"className":"break-words","href":"#references","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"References"]}]
4d:["$","ul",null,{"children":[["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://arxiv.org/abs/2503.19050","children":"Mist: Efficient Distributed Training of Large Language Models via Memory-Parallelism Co-Optimization"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://pacman.cs.tsinghua.edu.cn/~cwg/publication/10-1145-3689031-3717469/10-1145-3689031-3717469.pdf","children":"MEPipe: Democratizing LLM Training with Memory-Efficient Slice-Level Pipeline Scheduling on Cost-Effective Accelerators"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://arxiv.org/abs/2409.19256","children":"HybridFlow: A Flexible and Efficient RLHF Framework"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://arxiv.org/abs/2503.10725","children":"Samoyeds: Accelerating MoE Models with Structured Sparsity Leveraging Sparse Tensor Cores"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://arxiv.org/abs/2410.05004","children":"Fast State Restoration in LLM Serving with HCache"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://arxiv.org/abs/2312.05516","children":"Stateful Large Language Model Serving with Pensieve"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://arxiv.org/abs/2405.16444","children":"CacheBlend: Fast Large Language Model Serving for RAG with Cached Knowledge Fusion"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://arxiv.org/html/2407.00088v1","children":"T-MAC: CPU Renaissance via Table Lookup for Low-Bit LLM Deployment on Edge"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://arxiv.org/abs/2312.05215","children":"DeltaZip: Efficient Serving of Multiple Full-Model-Tuned LLMs"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://arxiv.org/abs/2409.19488","children":"A House United Within Itself: SLO-Awareness for On-Premises Containerized ML Inference Clusters via Faro"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://venero.github.io/publication/2025-EuroSys","children":"Chrono: Meticulous Hotness Measurement and Flexible Page Migration for Memory Tiering"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://www.linkedin.com/posts/jung-ho-ahn-9876748_our-research-group-will-present-a-paper-at-activity-7291709279550480384-gBmO","children":"PET: Proactive Demotion for Efficient Tiered Memory Management"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://yoon.ws/publication/adios-eurosys25.pdf","children":"Adios to Busy-Waiting for Microsecond-scale Memory Disaggregation"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://ipads.se.sjtu.edu.cn/_media/pub/members/paper.pdf","children":"CKI: A Hardware-Software Co-Design for Efficient Secure Containers"}]}],["$","li",null,{"children":["$","a",null,{"className":"break-words","target":"_blank","rel":"noopener noreferrer","href":"https://2025.eurosys.org/accepted-papers.html","children":"EuroSys 2025 Accepted Papers"}]}]]}]
4e:["$","div",null,{"className":"pt-6 pb-6 text-sm text-gray-700 dark:text-gray-300 glass p-4 rounded-xl","children":[["$","a",null,{"className":"hover:text-primary-600 dark:hover:text-primary-400 transition-colors","target":"_blank","rel":"nofollow","href":"https://mobile.twitter.com/search?q=https%3A%2F%2Fwww.yunwei37.com%2Fblog%2Feurosys-2025","children":"Discuss on Twitter"}]," • ",["$","a",null,{"className":"hover:text-primary-600 dark:hover:text-primary-400 transition-colors","target":"_blank","rel":"noopener noreferrer","href":"https://github.com/yunwei37/yunwei37-blog/blob/main/data/blog/eurosys-2025.mdx","children":"View on GitHub"}]]}]
4f:["$","div",null,{"className":"pt-6 pb-6 text-center text-gray-700 dark:text-gray-300 glass p-6 rounded-xl","id":"comment","children":["$","$L8e",null,{"slug":"eurosys-2025"}]}]
50:["$","footer",null,{"children":[["$","div",null,{"className":"divide-gray-200/30 text-sm leading-5 font-medium xl:col-start-1 xl:row-start-2 xl:divide-y dark:divide-gray-700/30","children":[["$","div",null,{"className":"py-4 xl:py-8","children":[["$","h2",null,{"className":"text-xs tracking-wide text-gray-600 uppercase dark:text-gray-300 mb-4","children":"Tags"}],["$","div",null,{"className":"flex flex-wrap gap-2","children":[["$","$L6","ebpf",{"href":"/tags/ebpf","className":"inline-block px-3 py-1 text-xs font-medium uppercase tracking-wide bg-primary-100 hover:bg-primary-200 dark:bg-primary-900/30 dark:hover:bg-primary-800/40 rounded-full transition-all duration-200 text-primary-800 hover:text-primary-900 dark:text-primary-300 dark:hover:text-primary-200 border border-primary-200/50 dark:border-primary-700/50","children":"ebpf"}],["$","$L6","systems",{"href":"/tags/systems","className":"inline-block px-3 py-1 text-xs font-medium uppercase tracking-wide bg-primary-100 hover:bg-primary-200 dark:bg-primary-900/30 dark:hover:bg-primary-800/40 rounded-full transition-all duration-200 text-primary-800 hover:text-primary-900 dark:text-primary-300 dark:hover:text-primary-200 border border-primary-200/50 dark:border-primary-700/50","children":"systems"}]]}]]}],["$","div",null,{"className":"flex justify-between py-4 xl:block xl:space-y-6 xl:py-8","children":[["$","div",null,{"className":"glass p-4 rounded-xl","children":[["$","h2",null,{"className":"text-xs tracking-wide text-gray-600 uppercase dark:text-gray-300 mb-2","children":"Previous Article"}],["$","div",null,{"className":"text-primary-600 hover:text-primary-700 dark:text-primary-400 dark:hover:text-primary-300 transition-colors","children":["$","$L6",null,{"className":"break-words","href":"/blog/gpu-profile-tool-impl","children":"GPU Profiling Under the Hood: An Implementation-Focused Survey of Modern Accelerator Tracing Tools"}]}]]}],["$","div",null,{"className":"glass p-4 rounded-xl","children":[["$","h2",null,{"className":"text-xs tracking-wide text-gray-600 uppercase dark:text-gray-300 mb-2","children":"Next Article"}],["$","div",null,{"className":"text-primary-600 hover:text-primary-700 dark:text-primary-400 dark:hover:text-primary-300 transition-colors","children":["$","$L6",null,{"className":"break-words","href":"/blog/asplos-2025","children":"ASPLOS 2025: Paper Summaries and Insights"}]}]]}]]}]]}],["$","div",null,{"className":"pt-4 xl:pt-8","children":["$","$L6",null,{"className":"inline-flex items-center glass px-4 py-2 rounded-xl text-primary-600 hover:text-primary-700 dark:text-primary-400 dark:hover:text-primary-300 transition-all duration-200 hover:scale-105","href":"/blog","aria-label":"Back to the blog","children":"← Back to the blog"}]}]]}]
51:["$","strong",null,{"children":"eliminating redundant coordination"}]
52:["$","strong",null,{"children":"1.5× to 20× throughput improvements"}]
53:["$","em",null,{"children":"Industry Relevance:"}]
54:["$","strong",null,{"children":"speed up alignment training"}]
55:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Samoyeds: Accelerating MoE Models with Structured Sparsity Leveraging Sparse Tensor Cores"}]," – ",["$","em",null,{"children":"Chenpeng Wu, Qiqi Gu, Heng Shi, Jianguo Yao, Haibing Guan."}]," This paper focuses on ",["$","strong",null,{"children":"Mixture-of-Experts (MoE) LLMs"}],", which trade off increased model size for sparse expert activation. ",["$","strong",null,{"children":"Samoyeds"}]," introduces an acceleration framework that exploits ",["$","em",null,{"children":"structured sparsity"}]," in both model ",["$","strong",null,{"children":"parameters and activations"}],". By defining a custom sparse data format and developing a specialized sparse–sparse matrix multiply kernel for NVIDIA’s Sparse Tensor Cores, Samoyeds can execute both weights and activations in sparse form. It also applies system-level optimizations to coordinate two-sided sparsity throughout the MoE execution. Experiments show ",["$","strong",null,{"children":"up to 1.99× kernel-level speedup"}]," and ",["$","strong",null,{"children":"1.58× end-to-end speedup"}]," on MoE models, along with substantial memory savings (enabling 4.4× larger batch sizes). ",["$","em",null,{"children":"Industry Relevance:"}]," For companies deploying ",["$","strong",null,{"children":"massive MoE models"}]," (e.g. for MT or recommendation), Samoyeds provides a way to leverage upcoming hardware support for sparsity to get ",["$","strong",null,{"children":"faster inference and training"}]," without sacrificing model quality."]}]}]
56:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Fast State Restoration in LLM Serving with HCache"}]," – ",["$","em",null,{"children":"Shiwei Gao, Youmin Chen, Jiwu Shu."}]," HCache addresses a bottleneck in LLM inference: efficiently restoring ",["$","strong",null,{"children":"cached conversational context"}]," (key–value attention states) for multi-turn dialogues and retrieval-augmented generation. Traditional systems either recompute dropped context from scratch or swap it to slow storage, incurring latency on cache miss. ",["$","strong",null,{"children":"HCache"}]," instead restores LLM key–value states ",["$","em",null,{"children":"from intermediate transformer activations"}],", using a “bubble-free” scheduler to overlap recomputation and I/O and a chunk-based storage manager to align data layout. This reduces “time-to-first-token” latency by ",["$","em",null,{"children":"up to 1.93×"}]," compared to pure KV offloading, while using only ~40–50% of the storage space. Versus fully recomputing from inputs, HCache cuts restoration time by up to ",["$","em",null,{"children":"5.7×"}],". ",["$","em",null,{"children":"Industry Relevance:"}]," For latency-critical LLM applications (chatbots, interactive agents), HCache can ",["$","strong",null,{"children":"dramatically speed up context switching"}]," or long-dialogue handling. This is directly relevant to cloud providers and API services striving to serve LLMs with low latency and high throughput."]}]}]
57:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Stateful Large Language Model Serving with Pensieve"}]," – ",["$","em",null,{"children":"Lingfan Yu, Jinkun Lin, Jinyang Li."}]," ",["$","strong",null,{"children":"Pensieve"}]," is a system for ",["$","strong",null,{"children":"multi-turn conversational LLM services"}]," that avoids re-processing the entire dialogue history on each turn. It maintains state across requests by caching previously encoded tokens’ key–value pairs in a multi-tier cache (using GPU memory for recent history and CPU memory for older, larger context). Pensieve also extends a recent paged-attention mechanism to allow cached attention over non-contiguous memory segments. By ",["$","strong",null,{"children":"eliminating redundant computation of prior turns"}],", Pensieve achieves ",["$","strong",null,{"children":"1.14×–3.0× higher throughput"}]," and significantly lower latency compared to stateless serving with frameworks like vLLM. ",["$","em",null,{"children":"Industry Relevance:"}]," Pensieve’s approach is valuable for ",["$","strong",null,{"children":"chatbot and assistant services"}]," – it improves efficiency when users engage in multi-turn conversations. This translates to cost savings and better user experience for industry players deploying chat-based LLM interfaces."]}]}]
58:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"CacheBlend: Fast Large Language Model Serving for RAG with Cached Knowledge Fusion"}]," – ",["$","em",null,{"children":"Jiayi Yao, Hanchen Li, Yuhan Liu, Siddhant Ray, Yihua Cheng, Qizheng Zhang, Kuntai Du, Shan Lu, Junchen Jiang."}]," CacheBlend tackles LLM serving in ",["$","strong",null,{"children":"retrieval-augmented generation (RAG)"}]," scenarios, where multiple retrieved text chunks are prepended as context. It observes that naively reusing cached key–value states of common context chunks is hard when they appear ",["$","em",null,{"children":"in the middle"}]," of an input rather than strictly as a prefix. ",["$","strong",null,{"children":"CacheBlend"}]," introduces a technique to ",["$","strong",null,{"children":"fuse precomputed caches"}]," from arbitrary text chunks: it selectively recomputes a ",["$","em",null,{"children":"small subset of tokens"}]," at chunk boundaries to correct for cross-chunk attention, while reusing the majority of cached states. This yields the same output quality as full recomputation but substantially speeds up the ",["$","em",null,{"children":"“prefill”"}]," stage of LLM inference. ",["$","em",null,{"children":"Industry Relevance:"}]," Many production LLM applications (enterprise Q&A, search assistants) rely on retrieved documents as context. CacheBlend’s method allows ",["$","strong",null,{"children":"faster LLM responses in RAG pipelines"}]," by reusing past computation, directly benefiting such industry use-cases with improved throughput."]}]}]
59:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"T-MAC: CPU Renaissance via Table Lookup for Low-Bit LLM Deployment on Edge"}]," – ",["$","em",null,{"children":"Jianyu Wei, Shijie Cao, Ting Cao, Lingxiao Ma, Lei Wang, Yanyong Zhang, Mao Yang."}]," T-MAC proposes a hardware/software co-design that enables efficient ",["$","strong",null,{"children":"LLM inference on CPUs"}]," by eliminating expensive multiplications on quantized models. The key idea is to convert the matrix multiply of low-precision weights and high-precision activations into a series of ",["$","em",null,{"children":"bit-wise table lookups"}],". T-MAC’s lookup tables precompute partial results for combinations of low-bit weight bits and activation values, thus performing mixed-precision GEMM without on-the-fly dequantization or multipliers. This yields a ",["$","em",null,{"children":"unified and linear-scaling"}]," kernel with respect to weight bit-width. Experiments on quantized LLaMA and BitNet models show ",["$","strong",null,{"children":"up to 4× higher throughput"}]," and ~70% less energy use than the highly optimized ",["$","code",null,{"children":"llama.cpp"}]," on CPUs. Impressively, on an Apple M2 Ultra chip, T-MAC generates 30 tokens/sec (single core) and 71 tokens/sec (8 cores) for a 3B model – even a Raspberry Pi 5 can achieve 11 tokens/sec. ",["$","em",null,{"children":"Industry Relevance:"}]," T-MAC enables ",["$","strong",null,{"children":"edge deployment of LLMs"}]," by dramatically improving CPU inference speed. This is important for mobile and IoT scenarios where GPUs are absent, and for companies aiming to run large models on consumer devices or in CPU-only cloud instances for cost savings."]}]}]
5a:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"DeltaZip: Efficient Serving of Multiple Full-Model-Tuned LLMs"}]," – ",["$","em",null,{"children":"Xiaozhe Yao, Qinghao Hu, Ana Klimovic."}]," DeltaZip addresses the scenario of serving many fine-tuned versions of an LLM (each fine-tuned with full model parameter updates). Deploying each model separately is memory-intensive and redundant, since fine-tuning typically results in only ",["$","em",null,{"children":"small weight differences"}]," from the base model. ",["$","strong",null,{"children":"DeltaZip"}]," introduces a system that ",["$","strong",null,{"children":"compresses and serves only the model “deltas”"}]," (the weight changes) on top of a shared base model. With a specialized compression algorithm co-designed with the serving runtime, DeltaZip can shrink fine-tune weight updates by up to ",["$","strong",null,{"children":"10×"}]," while preserving accuracy. At query time, it efficiently applies the compressed delta to the base model weights on the fly. The result is a ",["$","em",null,{"children":"multi-tenant LLM serving framework"}]," that improves throughput by ",["$","strong",null,{"children":"2× to 12×"}]," compared to naive per-model deployment. ",["$","em",null,{"children":"Industry Relevance:"}]," Modern AI services often host numerous domain-specific variants of a base model (for different customers or tasks). DeltaZip dramatically ",["$","strong",null,{"children":"reduces memory and compute overhead"}]," for multi-model serving, which is highly relevant for cloud providers or enterprises running dozens of fine-tuned LLMs concurrently."]}]}]
5b:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"SpInfer: Leveraging Low-Level Sparsity for Efficient Large Language Model Inference on GPUs"}]," – ",["$","em",null,{"children":"Ruibo Fan, Xiangrui Yu, Peijie Dong, Zeyu Li, Gu Gong, Qiang Wang, Wei Wang, Xiaowen Chu."}]," SpInfer is a ",["$","strong",null,{"children":"GPU inference framework for sparsified LLMs"}],". It exploits ",["$","em",null,{"children":"low-level sparsity patterns"}]," (e.g. zero values in weight matrices) to accelerate computation on modern GPUs. The framework introduces GPU Tensor Core–friendly algorithms to skip operations on zeros, and likely integrates with hardware intrinsics for structured sparsity. By customizing the CUDA kernels for sparse matrix multiplication and memory access, ",["$","strong",null,{"children":"SpInfer"}]," achieves significant speedups on models compressed via pruning or quantization. The system is ",["$","em",null,{"children":"high-performance and general"}],", making sparse LLM inference more practical. ",["$","em",null,{"children":"Industry Relevance:"}]," As companies seek to ",["$","strong",null,{"children":"compress large models (prune unimportant weights)"}]," to save cost, SpInfer enables them to actually realize ",["$","em",null,{"children":"latency and throughput gains"}]," from those sparse models on existing GPU hardware. It thus helps translate model compression into production performance improvements."]}]}]
5c:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Flex: Fast, Accurate DNN Inference on Low-Cost Edges Using Heterogeneous Accelerator Execution"}]," – ",["$","em",null,{"children":"Tanmoy Sen, Haiying Shen, Anand Iyer."}]," Flex targets ",["$","em",null,{"children":"resource-constrained edge devices"}]," (e.g. embedded boards) that have heterogeneous accelerators (CPU, small GPU, DSP, etc.). It presents a scheduler that ",["$","strong",null,{"children":"splits and maps parts of a deep neural network"}]," to the most suitable hardware units in parallel, rather than running the whole model on a single accelerator. By doing fine-grained partitioning and handling data movement efficiently, Flex achieves low inference latency without needing expensive hardware. ",["$","em",null,{"children":"Industry Relevance:"}]," IoT and edge applications (smart cameras, drones, etc.) often need to run DNNs but cannot afford power-hungry GPUs. Flex allows them to ",["$","strong",null,{"children":"utilize all available chips (GPU/CPU/NPU)"}]," to meet real-time requirements, expanding AI capabilities in edge devices with minimal cost."]}]}]
5d:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Hourglass: Enabling Efficient Split Federated Learning with Data Parallelism"}]," – ",["$","em",null,{"children":"Qiang He, Kaibin Wang, Zeqian Dong, Liang Yuan, Feifei Chen, Hai Jin, Yun Yang."}]," Hourglass improves ",["$","strong",null,{"children":"federated learning (FL)"}]," in scenarios where models are ",["$","em",null,{"children":"split"}]," between edge and server (split learning) and also distributed across multiple devices (data parallelism). It introduces an efficient protocol to coordinate these two forms of parallelism: many clients jointly train a model where the ",["$","em",null,{"children":"lower layers are on clients and upper layers on a server"}],". By carefully scheduling the synchronization of client-side updates and server-side model aggregation, ",["$","strong",null,{"children":"Hourglass"}]," reduces idle time and communication overhead. This leads to faster convergence and less strain on any single client or server. ",["$","em",null,{"children":"Industry Relevance:"}]," For cross-device FL (e.g. training on smartphones) or cross-silo FL (hospitals training on sensitive data), Hourglass enables ",["$","strong",null,{"children":"larger models to be trained collaboratively"}]," without compromising on speed, by splitting network layers and aggregating updates efficiently – beneficial for industries like healthcare or mobile AI."]}]}]
5e:["$","em",null,{"children":"Industry Relevance:"}]
5f:["$","strong",null,{"children":"VM consolidation"}]
60:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Eva: Cost-Efficient Cloud-Based Cluster Scheduling"}]," – ",["$","em",null,{"children":"Tzu-Tao Chang, Shivaram Venkataraman."}]," Eva is a cluster scheduler that optimizes for ",["$","strong",null,{"children":"cost efficiency"}]," in a cloud setting. Unlike traditional on-prem schedulers that consider makespan or fairness, Eva is cloud-aware: it decides when to use cheaper instance types (or even transient ones) and when to spin down nodes to save money. It likely uses a model of cloud pricing and workload urgency to make scheduling and scaling decisions that minimize dollar cost while meeting job requirements. ",["$","em",null,{"children":"Industry Relevance:"}]," Companies running large workloads on public clouds seek to ",["$","strong",null,{"children":"minimize cloud bills"}],". Eva’s scheduling approach aligns resource allocation with pricing and workload value, directly translating to ",["$","strong",null,{"children":"cost savings for cloud-based big data or AI pipelines"}],"."]}]}]
61:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"HyperAlloc: Efficient VM Memory De/Inflation via Hypervisor-Shared Page-Frame Allocators"}]," – ",["$","em",null,{"children":"Lars Wrenger, Kenny Albes, Marco Wurps, Christian Dietrich, Daniel Lohmann."}]," HyperAlloc improves the agility of adjusting a running VM’s memory (ballooning) by introducing a ",["$","strong",null,{"children":"shared page-frame allocator"}]," between guest and hypervisor. Traditional ballooning is slow and can cause performance hiccups, because the guest OS and hypervisor operate largely independently (leading to redundant moves and waits). HyperAlloc’s co-designed allocator allows the hypervisor to reclaim or grant pages to the VM ",["$","em",null,{"children":"much more directly and safely"}],". This yields near-immediate VM “memory inflation” or deflation without guest disruption. ",["$","em",null,{"children":"Industry Relevance:"}]," Cloud providers use memory ballooning for overcommitment. HyperAlloc makes this ",["$","strong",null,{"children":"faster and smoother"}],", meaning better VM density and responsiveness – providers can run more VMs per host and rapidly mitigate memory pressure, improving utilization and customer experience."]}]}]
62:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Serverless Cold Starts and Where to Find Them"}]," – ",["$","em",null,{"children":"Artjom Joosen, Ahmed Hassan, Martin Asenov, Rajkarn Singh, Luke Darlow, Jianfeng Wang, Qiwen Deng, Adam Barker."}]," This study takes a deep look at ",["$","strong",null,{"children":"cold start latency in serverless platforms"}],". It likely characterizes the various sources of delay (container initialization, code download, JIT, etc.) across different providers or runtimes. By tracing and measuring production systems, it identifies “where” the time is spent and which factors (e.g. package size, runtime language, VM warm-up) dominate cold start. It may also propose improvements or caching mechanisms to reduce these delays. ",["$","em",null,{"children":"Industry Relevance:"}]," Cold starts degrade user experience and limit serverless use in low-latency apps. Cloud providers (and developers) will benefit from the insights – for instance, this research could guide ",["$","strong",null,{"children":"optimizations in FaaS platforms"}]," or best practices (like using certain runtime configurations) to minimize cold-start impact."]}]}]
63:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"SeBS-Flow: Benchmarking Serverless Cloud Function Workflows"}]," – ",["$","em",null,{"children":"Larissa Schmid, Marcin Copik, Alexandru Calotoiu, Laurin Brandner, Anne Koziolek, Torsten Hoefler."}]," SeBS-Flow extends serverless benchmarking to ",["$","strong",null,{"children":"function workflows"}],", not just individual functions. It provides a suite of workflow patterns (sequence, parallel, conditionals, etc.) and metrics to evaluate end-to-end performance, failure handling, and cost across cloud providers. By benchmarking workflows, it uncovers overheads in orchestration (e.g. state passing, coordination delays) that are not seen in single-function benchmarks. ",["$","em",null,{"children":"Industry Relevance:"}]," As serverless adoption grows, complex applications involve ",["$","strong",null,{"children":"multiple functions chained together"}],". Cloud users and providers can use SeBS-Flow to ",["$","strong",null,{"children":"identify bottlenecks in their workflow managers"}]," (like AWS Step Functions or Azure Durable Functions) and optimize throughput, ensuring that multi-step serverless applications run efficiently."]}]}]
64:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"AlloyStack: A Library Operating System for Serverless Workflow Applications"}]," – ",["$","em",null,{"children":"Jianing You, Kang Chen, Laiping Zhao, Yiming Li, Yichi Chen, Yuxuan Du, Yanjie Wang, Luhang Wen, Keyang Hu, Keqiu Li."}]," AlloyStack introduces a LibOS approach to improve performance for ",["$","strong",null,{"children":"serverless workflows"}],". Instead of each function in a workflow running in a separate container/VM with its own OS, AlloyStack provides a ",["$","strong",null,{"children":"unified library OS"}]," that can host an entire workflow (multiple functions) within a single sandbox while still enforcing isolation from other workflows. By “alloying” multiple functions together, it avoids the overhead of context-switching and communication between functions through external services. The LibOS likely offers lightweight isolation and fast inter-function calls. ",["$","em",null,{"children":"Industry Relevance:"}]," This is aimed at ",["$","strong",null,{"children":"workflow-heavy serverless apps"}]," (e.g. an ETL pipeline of several functions). AlloyStack can significantly ",["$","strong",null,{"children":"cut latency and resource duplication"}]," in such apps, making serverless viable for more demanding, tightly-coupled workloads that previously suffered from function-to-function invocation overhead."]}]}]
65:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Improving GPU Sharing Performance through Adaptive Bubbleless Spatial-Temporal Sharing"}]," – ",["$","em",null,{"children":"Shulai Zhang, Quan Chen, Weihao Cui, Han Zhao, Chunyu Xue, Zhen Zheng, Wei Lin, Minyi Guo."}]," This work deals with ",["$","strong",null,{"children":"GPU sharing in multi-tenant clusters"}],". It identifies that static partitioning or naive time-slicing can leave GPU resources underutilized (creating idle “bubbles”) when workloads don’t perfectly align. The proposed system adaptively adjusts how GPUs are split spatially (SM partitions, memory slices) and temporally (time quanta) to ",["$","strong",null,{"children":"eliminate bubbles"}]," in utilization. For example, if one job’s load drops, another can immediately seize the freed GPU capacity. The method likely uses feedback from GPU performance counters to resize partitions or scheduling slices on the fly. ",["$","em",null,{"children":"Industry Relevance:"}]," Cloud platforms offering ",["$","strong",null,{"children":"fractional GPUs"}]," or multiple jobs per GPU (common in training and inferencing clusters) can achieve ",["$","strong",null,{"children":"higher aggregate throughput"}]," and fairness by adopting such adaptive schemes, directly translating to cost savings and better performance for customers."]}]}]
66:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Multiplexing Dynamic Deep Learning Workloads with SLO-awareness in GPU Clusters"}]," – ",["$","em",null,{"children":"Wenyan Chen, Chengzhi Lu, Huanle Xu, Kejiang Ye, Chengzhong Xu."}]," This paper also tackles multi-tenant ",["$","strong",null,{"children":"GPU cluster scheduling"}]," but emphasizes SLO (service level objective) compliance for each job. It introduces a scheduler that ",["$","strong",null,{"children":"dynamically multiplexes DL workloads"}]," (with time-varying resource usage) on the same GPU while ensuring each meets its training or inference latency SLO. Likely, it monitors each job’s progress and GPU usage, and when contention arises, it smartly decides which job to prioritize or temporarily throttle, so that no job violates its deadline or throughput target. ",["$","em",null,{"children":"Industry Relevance:"}]," In AI cloud services, ",["$","strong",null,{"children":"guaranteeing performance isolation"}]," is crucial – e.g., an inferencing service should not spike latency because a neighbor is doing training. An SLO-aware GPU multiplexing system allows providers to safely ",["$","strong",null,{"children":"increase GPU utilization (run more jobs per GPU)"}]," without risking SLA breaches."]}]}]
67:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Moko: Marrying Python with Big Data Systems"}]," – ",["$","em",null,{"children":"Ke Meng, Tao He, Sijie Shen, Lei Wang, Wenyuan Yu, Jingren Zhou."}]," Moko is a system that seamlessly integrates ",["$","strong",null,{"children":"Python’s ease of use with the performance of big data systems"}],". It likely allows developers to write data processing logic in Python while transparently leveraging optimized engines (like Spark, Flink, or C++ backends) under the hood. Moko might use techniques like runtime specialization, intelligent caching, or distributed scheduling of Python UDFs to mitigate the usual slowdown from Python’s interpreter. Essentially, it “marries” Python’s flexibility with efficient execution by the data platform. ",["$","em",null,{"children":"Industry Relevance:"}]," Many data scientists prefer Python, but enterprises need the scale of distributed data systems. Moko lets teams ",["$","strong",null,{"children":"retain Python productivity without sacrificing big data scalability"}],", accelerating development cycles in industry for ETL, analytics, and ML pipelines."]}]}]
68:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Collaborative Text Editing with Eg‐walker: Better, Faster, Smaller"}]," – ",["$","em",null,{"children":"Joseph Gentle, Martin Kleppmann."}]," Eg-walker presents a new approach to ",["$","strong",null,{"children":"real-time collaborative text editing"}],", improving on prior techniques like Operational Transform (OT) or Conflict-free Replicated Data Types (CRDTs). “Better, faster, smaller” suggests Eg-walker achieves ",["$","em",null,{"children":"lower latency, less metadata overhead, and better consistency"}]," for syncing document edits among users. It possibly introduces an algorithm that avoids tombstones or excessive buffering (common issues in CRDT-based editors) by walking through the document state in an efficient way to integrate changes. The result is a collaboration engine that handles concurrent edits with minimal payload size and high responsiveness, even for large documents. ",["$","em",null,{"children":"Industry Relevance:"}]," Collaborative editing is foundational for products like Google Docs, Office 365, and code collaboration tools. Eg-walker’s improvements could ",["$","strong",null,{"children":"reduce operational costs (less data to sync)"}]," and improve user experience with more fluid, robust real-time editing – highly relevant to any company offering collaborative applications."]}]}]
69:["$","em",null,{"children":"Industry Relevance:"}]
6a:["$","strong",null,{"children":"differentiated QoS"}]
6b:["$","strong",null,{"children":"finer control and easier deployment"}]
6c:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Marlin: Enabling High-Throughput Congestion Control Testing in Large-Scale Networks"}]," – ",["$","em",null,{"children":"Yanqing Chen, Li Wang, Jingzhi Wang, Songyue Liu, Keqiang He, Jian Wang, Xiaoliang Wang, Wanchun Dou, Guihai Chen, Chen Tian."}]," Marlin provides a platform or methodology for ",["$","strong",null,{"children":"rapidly testing new congestion control protocols"}]," at scale. It likely uses simulation or emulation with real traffic patterns, optimized to run experiments with many flows and nodes faster than packet-level simulators. It might incorporate techniques like abstraction of link sharing or parallel simulation to achieve high throughput testing (covering large parameter spaces). ",["$","em",null,{"children":"Industry Relevance:"}]," Every new CC algorithm (like BBR, HPCC, etc.) needs extensive testing under realistic conditions. Marlin can ",["$","strong",null,{"children":"accelerate the development and evaluation cycle"}]," for industry researchers building next-gen network algorithms, ensuring robust results before deployment in production networks."]}]}]
6d:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Phantom: Virtualizing Switch Register Resources for Accurate Sketch-based Network Measurement"}]," – ",["$","em",null,{"children":"Xiang Chen, Hongyan Liu, Zhengyan Zhou, Xi Sun, Wenbin Zhang, Hongyang Du, Dong Zhang, Xuan Liu, Haifeng Zhou, Dusit Niyato, Qun Huang, Chunming Wu, Kui Ren."}]," Phantom focuses on ",["$","strong",null,{"children":"network measurement sketches"}]," (like count-min, Bloom filters) which typically use switch memory/registers to track flow statistics. Hardware registers are scarce, so Phantom introduces a ",["$","em",null,{"children":"virtualization layer"}]," that gives the illusion of more counter space by swapping and sharing registers efficiently among multiple sketches or tasks. It likely uses fast algorithms to move sketch data to external memory (or among registers) without losing accuracy, perhaps by time-slicing the measurement tasks or compressing counts. This allows more comprehensive measurements to run concurrently on a switch without exceeding hardware limits. ",["$","em",null,{"children":"Industry Relevance:"}]," For network operators (cloud or ISP), ",["$","strong",null,{"children":"accurate real-time traffic measurement"}]," is vital for DDoS detection, billing, and performance tuning. Phantom lets them deploy more measurement utilities on the same hardware switches, enhancing observability of network traffic without needing expensive hardware upgrades."]}]}]
6e:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Pegasus: Transparent and Unified Kernel-Bypass Networking for Fast Local and Remote Communication"}]," – ",["$","em",null,{"children":"Dinglan Peng, Congyu Liu, Tapti Palit, Anjo Vahldiek-Oberwagner, Mona Vij, Pedro Fonseca."}]," Pegasus proposes a unified approach to accelerate communication both ",["$","strong",null,{"children":"within a single machine (inter-process)"}]," and ",["$","strong",null,{"children":"across machines (network)"}]," by bypassing the kernel. It likely provides an API or layer that applications use for message-passing or RPC, which internally uses kernel-bypass (e.g. DPDK or RDMA) whether the destination is local or remote. This transparency means developers don’t have to handle IPC differently from RPC. Pegasus probably ensures that local communications short-circuit with shared memory, and remote goes over RDMA/Ethernet, but under one abstraction. ",["$","em",null,{"children":"Industry Relevance:"}]," In modern cloud software (especially microservices), the boundary between local and distributed communication blurs (e.g. a service might be co-located or remote). Pegasus can ",["$","strong",null,{"children":"improve performance (low latency, high throughput)"}]," by using the fastest path available while simplifying development. This is beneficial in data centers for high-performance computing and distributed systems where both inter-thread and inter-node communications are critical."]}]}]
6f:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Byte vSwitch: A High-Performance Virtual Switch for Cloud Networking"}]," – ",["$","em",null,{"children":"Xin Wang, Deguo Li, Zhihong Wang, Lidong Jiang, Shubo Wen, Daxiang Kang, Engin Arslan, Peng He, Xinyu Qian, Bin Niu, Jianwen Pi, Xiaoning Ding, Ke Lin, Hao Luo."}]," Byte vSwitch is a new software virtual switch (like OVS) optimized for large cloud environments (developed by ByteDance). It likely achieves ",["$","em",null,{"children":"near line-rate packet processing in software"}]," by using techniques such as batching, lock-free data structures, NUMA-aware scheduling, and perhaps offloads (e.g. leveraging NIC hardware). It might integrate tightly with the hypervisor or container runtime to reduce context switches and memory copies (zero-copy packet paths). The result is a virtual switch that can handle very high throughput with low latency, even with many VMs/containers on a host. ",["$","em",null,{"children":"Industry Relevance:"}]," This directly serves cloud providers and large-scale SaaS operators – a faster vSwitch means ",["$","strong",null,{"children":"higher network I/O performance for VMs/containers"}],", enabling data-intensive applications and NFV (Network Function Virtualization) with less overhead. It improves the efficiency of network virtualization, which is a cornerstone of multi-tenant clouds."]}]}]
70:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Atlas: Towards Real-Time Verification in Large-Scale Networks via a Native Distributed Architecture"}]," – ",["$","em",null,{"children":"Mingxiao Ma, Yuehan Zhang, Jingyu Wang, Bo He, Chenyang Zhao, Qi Qi, Zirui Zhuang, Haifeng Sun, Lingqi Guo, Yuebin Guo, Gong Zhang, Jianxin Liao."}]," Atlas is a distributed system for ",["$","strong",null,{"children":"continuous network verification"}]," (checking that the network’s forwarding behavior meets policy, e.g. no loops, no blackholes, security isolation). Unlike offline verification tools, Atlas operates in real-time and at scale by ",["$","strong",null,{"children":"partitioning the verification task across multiple nodes"}]," (e.g. each network device or each region verifies local properties, and results are aggregated). It likely uses a graph or SAT solver that is distributed, so verification computation grows with the network without central bottlenecks. This native distributed architecture means each router/switch might contribute to verifying reachability or compliance in parallel. ",["$","em",null,{"children":"Industry Relevance:"}]," Large networks (cloud data centers, telco networks) need ",["$","strong",null,{"children":"fast verification of configurations"}]," to catch errors before they cause outages. Atlas’s approach could allow operators to get ",["$","strong",null,{"children":"instant alerts to misconfigurations or policy violations"}]," even in huge networks, improving reliability and reducing downtime caused by network config errors."]}]}]
71:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Ladon: High-Performance Multi-BFT Consensus via Dynamic Global Ordering"}]," – ",["$","em",null,{"children":"Hanzheng Lyu, Shaokang Xie, Jianyu Niu, Chen Feng, Yinqian Zhang, Ivan Beschastnikh."}]," Ladon addresses performance of ",["$","em",null,{"children":"Byzantine Fault Tolerant (BFT) consensus"}]," (used in blockchain or critical systems) by introducing a ",["$","strong",null,{"children":"dynamic global ordering service"}],". Classic BFT protocols struggle to scale in throughput and participant count. Ladon likely separates the ordering of requests from the agreement, using a smaller core (or a hierarchy) to establish a total order of transactions quickly, which the broader set of replicas then validate and execute. This dynamic ordering might adjust leaders or quorums on the fly based on load or faults, improving throughput under varying conditions. ",["$","em",null,{"children":"Industry Relevance:"}]," Permissioned blockchains and other BFT-replicated systems (financial ledgers, etc.) often need to handle ",["$","strong",null,{"children":"high transaction volumes securely"}],". Ladon’s multi-BFT approach could ",["$","strong",null,{"children":"significantly boost throughput and lower latency"}]," for such systems, making BFT practical for industry use-cases that demand both strong fault tolerance and high performance (e.g. consortium blockchain between banks)."]}]}]
72:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Achilles: Efficient TEE-Assisted BFT Consensus via Rollback Resilient Recovery"}]," – ",["$","em",null,{"children":"Jianyu Niu, Guanlong Wu, Shengqi Liu, Xiaoqing Wen, Jiangshan Yu, Yinqian Zhang."}]," Achilles leverages Trusted Execution Environments (Intel SGX or similar) to improve BFT consensus. TEEs can reduce the number of replicas needed (since some trust is placed in secure enclaves) but come with performance costs and new failure modes (e.g. enclave crashes). Achilles introduces a ",["$","em",null,{"children":"rollback-resilient recovery"}]," mechanism to handle enclave resets or state rollbacks without compromising security or liveness. Essentially, it makes a TEE-based replica “sticky” to its state so an attacker can’t reset it to violate protocol assumptions. This yields a consensus protocol that uses fewer replicas (thanks to TEEs) yet remains efficient and secure. ",["$","em",null,{"children":"Industry Relevance:"}]," In consortium networks or databases, ",["$","strong",null,{"children":"combining hardware security (TEE) with consensus"}]," can reduce overhead (e.g. 4 replicas instead of 3f+1). Achilles makes such hybrid approaches safer and faster, potentially encouraging adoption of TEEs for blockchain and critical consensus services where performance and security are both paramount."]}]}]
73:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"ParallelEVM: Operation-Level Concurrent Transaction Execution for EVM-Compatible Blockchains"}]," – ",["$","em",null,{"children":"Haoran Lin, Hang Feng, Yajin Zhou, Lei Wu."}]," ParallelEVM aims to speed up Ethereum-like blockchain throughput by ",["$","strong",null,{"children":"executing smart contract operations in parallel"}]," when safe. It analyzes transactions at the operation level (within the EVM opcodes) to find independent steps or non-conflicting state accesses, so that multiple operations (possibly from different transactions) can run simultaneously on multi-core processors. It likely deals with issues of atomicity and order by careful scheduling or using speculative execution with rollback if a conflict is detected. ",["$","em",null,{"children":"Industry Relevance:"}]," Blockchain platforms face scalability limits. By ",["$","strong",null,{"children":"parallelizing smart contract execution"}],", throughput (TPS) can increase significantly. This is valuable for public and private EVM-compatible chains (Ethereum, Binance Chain, etc.), enabling them to handle more transactions without sharding or layer-2 solutions, directly benefiting the crypto industry and decentralized app performance."]}]}]
74:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"BINGO: Radix-based Bias Factorization for Random Walk on Dynamic Graphs"}]," – ",["$","em",null,{"children":"Pinhuan Wang, Chengying Huan, Zhibin Wang, Chen Tian, Yuede Ji, Hang Liu."}]," BINGO is an algorithmic systems paper focusing on ",["$","strong",null,{"children":"random walks in dynamic graphs"}]," (graphs that change over time). It proposes a ",["$","em",null,{"children":"radix-based factorization"}]," technique to efficiently update and sample random walks as the graph evolves. Likely, it factorizes the probabilities or biases of walk transitions into components (radix digits) such that updates (like edge weight changes or additions) only affect a portion of the precomputed structure, enabling fast updates. This yields faster generation of random walk samples on the fly for things like graph neural networks or link analysis on dynamic networks. ",["$","em",null,{"children":"Industry Relevance:"}]," Random walks are used in recommendation (e.g. Pinterest’s Pixie), fraud detection, and network analysis. BINGO allows ",["$","strong",null,{"children":"real-time graph mining on evolving data"}]," (social networks, transaction networks) by keeping the random walk process efficient even as the graph changes, which is useful for social media analytics, financial transaction monitoring, etc."]}]}]
75:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"CAPSys: Contention-aware Task Placement for Data Stream Processing"}]," – ",["$","em",null,{"children":"Yuanli Wang, Lei Huang, Zikun Wang, Vasiliki Kalavri, Ibrahim Matta."}]," CAPSys deals with placing streaming computation tasks (operators) on machines in a way that ",["$","strong",null,{"children":"minimizes resource contention"}],". In stream processing frameworks (Flink, Spark Streaming), multiple tasks may compete for CPU, network, or memory, causing unpredictable latency. This scheduler likely profiles or predicts contention between specific operators (for instance, two tasks both heavy on network I/O shouldn’t co-locate on the same host) and places them on different machines or cores. By being “contention-aware,” it improves overall throughput and reduces processing latency. ",["$","em",null,{"children":"Industry Relevance:"}]," Streaming analytics pipelines (for telemetry, click streams, etc.) are latency-sensitive. CAPSys can ",["$","strong",null,{"children":"boost the stability and throughput of streaming jobs"}]," in cloud environments by intelligently packing tasks – valuable for any company processing big data streams in real-time where inefficient placement would cause bottlenecks."]}]}]
76:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Impeller: Stream Processing on Shared Logs"}]," – ",["$","em",null,{"children":"Zhiting Zhu, Zhipeng Jia, Newton Ni, Dixin Tang, Emmett Witchel."}]," Impeller bridges ",["$","strong",null,{"children":"stream processing with a shared log abstraction"}],". It builds a stream processing engine on top of a ",["$","em",null,{"children":"shared log"}]," (a durable, totally ordered log of events accessible to multiple readers/writers). This design unifies historical and online processing: streaming queries can treat the log as the single source of truth for both real-time and past data. Impeller likely provides strong consistency and failure recovery by relying on the shared log (which could be implemented via Apache Kafka, or a log-based database). It enables stateful stream operators to scale out or recover by replaying from the log as needed. ",["$","em",null,{"children":"Industry Relevance:"}]," The idea of a “",["$","em",null,{"children":"log as a database"}],"” (as seen in LinkedIn’s Samza, or Kafka Streams) is powerful. Impeller gives cloud and big-data companies a way to ",["$","strong",null,{"children":"simplify their Lambda architectures"}]," – the same log underpins streaming and batch, ensuring no data loss or inconsistency. This can lower complexity and improve the reliability of real-time analytics pipelines used in fintech, IoT, etc."]}]}]
77:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"NeuStream: Bridging Deep Learning Serving and Stream Processing"}]," – ",["$","em",null,{"children":"Haochen Yuan, Yuanqing Wang, Wenhao Xie, Yu Cheng, Ziming Miao, Lingxiao Ma, Jilong Xue, Zhi Yang."}]," NeuStream integrates ",["$","strong",null,{"children":"ML model inference into streaming data processing pipelines"}],". Instead of treating model serving (e.g. image classification or anomaly detection) as an external RPC from a stream job, NeuStream makes it a native streaming operator. It likely optimizes the scheduling and batching of inference calls in the context of a streaming engine, so that throughput is maximized and backpressure is handled gracefully. Essentially, it closes the gap where streaming systems handle data transformations and then call out to a model server – NeuStream merges these, avoiding network overhead and synchronization issues by perhaps co-locating model executors within stream processors and aligning their batching with stream micro-batches. ",["$","em",null,{"children":"Industry Relevance:"}]," Many real-time applications involve both data stream processing and ML inference (for example, analyzing sensor data with an AI model). NeuStream’s unified approach can ",["$","strong",null,{"children":"reduce end-to-end latency and simplify system architecture"}],", beneficial for industries like fraud detection (stream of transactions + ML), monitoring (logs + anomaly models), etc., enabling them to act on insights faster."]}]}]
78:["$","em",null,{"children":"Industry Relevance:"}]
79:["$","strong",null,{"children":"NVMe SSDs or byte-addressable NVM (e.g. Intel Optane)"}]
7a:["$","strong",null,{"children":"maximize memory utilization"}]
7b:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"PET: Proactive Demotion for Efficient Tiered Memory Management"}]," – ",["$","em",null,{"children":"Wanju Doh, Yaebin Moon, Seoyoung Ko, Seunghwan Chung, Kwanhee Kyung, Eojin Lee, Jung Ho Ahn."}]," PET focuses on the “demotion” side of tiered memory (moving data from DRAM to slower memory) and does so ",["$","em",null,{"children":"proactively"}],". It observes that many systems wait until DRAM is full or a page becomes cold to evict it, which can be suboptimal. ",["$","strong",null,{"children":"PET"}]," instead leverages insights about ",["$","strong",null,{"children":"application memory allocation patterns"}]," – introducing the concept of a ",["$","strong",null,{"children":"“PET-block”"}],", which groups pages based on allocation context (e.g. the malloc or memory region). It proactively demotes entire PET-blocks that are predicted to be used less, ",["$","em",null,{"children":"before"}]," DRAM pressure becomes critical. This alignment with app behavior yields big DRAM savings with little performance hit. In evaluations, PET reduced DRAM usage by ~40% on average (up to 80%) with minimal slowdown. It also outperformed existing tiering schemes under high memory pressure, maintaining better performance. ",["$","em",null,{"children":"Industry Relevance:"}]," Proactively offloading infrequently used data to cheaper memory means ",["$","strong",null,{"children":"higher effective memory capacity at lower cost"}],". Cloud providers or enterprises running large in-memory workloads can use PET to cut hardware costs (using NVMe or remote memory for colder data) while preserving application speed, which is a direct economic win."]}]}]
7c:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Adios to Busy-Waiting for Microsecond-scale Memory Disaggregation"}]," – ",["$","em",null,{"children":"Wonsup Yoon, Jisu Ok, Sue Moon, Youngjin Kwon."}]," ",["$","strong",null,{"children":"Adios"}]," revisits the OS page fault handler design in the context of ultra-fast disaggregated memory (where a page fault fetch over RDMA can be only a few microseconds). Prior systems like Fastswap or DiLOS chose to ",["$","em",null,{"children":"busy-wait"}]," on page faults (spinning until data arrives) to avoid slow context-switches and interrupts, but Adios shows this causes head-of-line blocking and underutilized CPU/network resources. Instead, Adios ",["$","strong",null,{"children":"reintroduces yielding"}]," during page faults but with a twist: it places the page fault handler and scheduler in the same userspace address space and uses ultra-lightweight user-level threads (“unithreads”). This way, when a fault occurs, the thread can yield and let another ready thread run, with only a few nanoseconds of overhead – avoiding CPU wasting cycles on busy-wait and allowing more outstanding RDMA requests. Adios also includes a new dispatch algorithm to balance RDMA queue usage across threads. Altogether, it outperforms the busy-wait baseline DiLOS by ",["$","em",null,{"children":"1.07×–1.64× throughput"}]," and cuts P99.9 tail latency by ",["$","strong",null,{"children":"1.99×–10.9×"}]," in real workloads. ",["$","em",null,{"children":"Industry Relevance:"}]," Disaggregated memory is on the horizon via CXL and RDMA pools. Adios provides the OS mechanisms to ",["$","strong",null,{"children":"fully exploit high-speed remote memory"}]," – yielding better CPU utilization and lower tail latency, which is crucial for making disaggregated architectures practical in industry (where QoS and efficiency determine adoption)."]}]}]
7d:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Pre-Stores: Proactive Software-guided Movement of Data Down the Memory Hierarchy"}]," – ",["$","em",null,{"children":"Xiaoxiang Wu, Baptiste Lepers, Willy Zwaenepoel."}]," Pre-Stores takes a proactive approach to moving data ",["$","strong",null,{"children":"from CPU caches down to lower levels (e.g. DRAM or NVM)"}]," before it’s evicted under pressure. It presumably allows software (perhaps the compiler or OS) to explicitly “demote” cache lines or pages that it predicts won’t be reused soon, instead of waiting for hardware LRU to evict them. By doing so, it could reduce cache thrashing and also prepare larger chunks of data for eviction (amortizing cost). Essentially, it’s the analog of prefetch but for eviction (“pre-evict” = pre-store to lower level). This can improve cache efficiency and memory bandwidth usage for certain patterns. ",["$","em",null,{"children":"Industry Relevance:"}]," Workloads with ",["$","em",null,{"children":"streaming or phase behavior"}]," (like batch data processing) could benefit, as they often blow out caches. Pre-Stores could ",["$","strong",null,{"children":"increase effective cache size and reduce interference"}]," for high-performance computing and big-data jobs, potentially giving predictable performance improvements in cloud VMs or any environment where software can be tuned with such hints."]}]}]
7e:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"RAKIS: Secure Fast I/O Primitives Across Trust Boundaries on Intel SGX"}]," – ",["$","em",null,{"children":"Mansour Alharthi, Fan Sang, Dmitrii Kuvaiskii, Mona Vij, Taesoo Kim."}]," RAKIS addresses the notoriously slow I/O when using Intel SGX enclaves. SGX enclaves are secure but performing I/O (network, disk) requires exiting the enclave (OCALLs) which is slow and breaks security if not done carefully. RAKIS provides a set of ",["$","strong",null,{"children":"secure, optimized I/O primitives"}]," that span inside and outside enclave seamlessly. It likely introduces a mechanism for encryption/decryption and data copying that minimizes transitions – perhaps by batching I/O requests or sharing memory buffers securely between enclave and untrusted OS. The result is a much faster way for enclave code to perform file or socket I/O without compromising the trust model. ",["$","em",null,{"children":"Industry Relevance:"}]," SGX and TEEs are used for confidential computing (e.g. databases, secure ML inference). RAKIS helps such applications achieve near-native I/O throughput, which ",["$","strong",null,{"children":"broadens the range of apps that can run in TEEs"}]," without unacceptable overhead – important for cloud vendors offering confidential computing instances."]}]}]
7f:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Efeu: Generating Efficient, Verified, Hybrid Hardware/Software Drivers for I2C Devices"}]," – ",["$","em",null,{"children":"Daniel Schwyn, Zikai Liu, Timothy Roscoe."}]," Efeu is a framework to automatically generate device drivers for I²C devices, splitting functionality between hardware (FPGA or ASIC) and software. Many I²C peripherals (sensors, etc.) have timing-sensitive or frequent operations that could be offloaded to a small hardware core, while the rest remains in software. Efeu likely takes a high-level device specification and then synthesizes a “hybrid” driver: part runs on an FPGA (to handle frequent polling or data moves), and part as normal driver code – and it verifies correctness of this partition. This yields drivers that are both efficient (offloading low-level bit-banging or timing-critical loops to hardware) and reliable (formally verified against spec). ",["$","em",null,{"children":"Industry Relevance:"}]," Writing drivers for the plethora of IoT devices is time-consuming, and pure software might not meet performance for some low-level tasks. Efeu could ",["$","strong",null,{"children":"reduce development effort and bugs"}]," by generating drivers automatically, and also ",["$","strong",null,{"children":"improve performance for device-heavy systems"}]," (like sensor hubs or robotics) by leveraging simple hardware accelerators – a win for embedded systems development in industry."]}]}]
80:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"eNetSTL: Towards an In-kernel Library for High-Performance eBPF-based Network Functions"}]," – ",["$","em",null,{"children":"Bin Yang, Dian Shen, Junxue Zhang, Hanlin Yang, Lunqi Zhao, Beilun Wang, Guyue Liu, Kai Chen."}]," eNetSTL is essentially a C++ STL-like collection of data structures/utilities optimized for ",["$","strong",null,{"children":"in-kernel eBPF programs"}],". Writing high-performance eBPF code is hard due to limited libraries and verification constraints. eNetSTL likely provides vetted, BPF-friendly implementations of common structures (maps, queues) and algorithms that can be used in eBPF hooks for packet processing. By being in-kernel and BPF-safe, these can execute with minimal overhead. It essentially enriches the eBPF programming environment to make it easier and faster to create complex in-kernel network functions (firewalls, telemetry, load balancers) without kernel module programming. ",["$","em",null,{"children":"Industry Relevance:"}]," eBPF is exploding in use (for observability, networking, security). eNetSTL would allow developers to ",["$","strong",null,{"children":"write more sophisticated eBPF programs faster"}],", with confidence in their performance and safety. This can accelerate the pace of innovation in kernel extensions and help companies like Netflix, Facebook, Cloudflare (big eBPF users) push more logic into the kernel datapath safely for performance gains."]}]}]
81:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Understanding the Linux Kernel, Visually"}]," – ",["$","em",null,{"children":"Hanzhi Liu, Yanyan Jiang, Chang Xu."}]," This is a tool/system aimed at ",["$","strong",null,{"children":"visualizing the internal behavior of the Linux kernel"}]," to aid understanding and debugging. It presumably traces kernel events (scheduling, memory allocation, syscalls) and generates intuitive visual representations (graphs, timelines) that show how the kernel is operating. This can help developers catch issues like deadlocks, long interrupt disabling, or just learn kernel behavior by seeing it in action. ",["$","em",null,{"children":"Industry Relevance:"}]," Kernel engineering and performance tuning are critical but difficult due to complexity. A visualization tool can ",["$","strong",null,{"children":"shorten debug time and training time"}]," for kernel developers, SREs, or OS researchers by making low-level behavior observable. Companies working on custom kernels or diagnosing OS performance (e.g. Android OEMs, cloud OS teams) could benefit from such a tool to quickly pinpoint problems."]}]}]
82:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"“Garbage Collection Does Not Only Collect Garbage”: Piggybacking-Style Defragmentation for Deduplicated Backup Storage"}]," – ",["$","em",null,{"children":"Dingbang Liu, Xiangyu Zou, Tao Lu, Philip Shilane, Wen Xia, Wenxuan Huang, Yanqi Pan, Hao Huang."}]," In deduplicated backup systems, data fragmentation over time hurts restore performance. This paper proposes a ",["$","em",null,{"children":"piggybacked defragmentation"}]," approach that runs opportunistically during normal garbage collection (GC) cycles. When backup data is deleted and chunks are freed, the system uses that chance not only to collect garbage but to ",["$","strong",null,{"children":"relocate remaining live chunks"}]," to more contiguous storage areas, thereby defragmenting the storage in the background. By integrating defrag into routine GC (instead of needing separate heavy defrag jobs), it reduces write amplification and space overhead. The result is a backup store that maintains high read/restore efficiency over time with little additional cost. ",["$","em",null,{"children":"Industry Relevance:"}]," Enterprise backup appliances (like Dell EMC Data Domain, which one author is from) suffer from ",["$","strong",null,{"children":"fragmentation as data evolves"}],", making recovery slower. This technique can ",["$","strong",null,{"children":"improve restore speeds and overall storage utilization"}]," in such products, giving customers faster disaster recovery and backup expiration without performance degradation."]}]}]
83:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Overcoming the Last Mile between Log-Structured File Systems and Persistent Memory via Scatter Logging"}]," – ",["$","em",null,{"children":"Yifeng Zhang, Yanqi Pan, Hao Huang, Yuchen Shan, Wen Xia."}]," This work adapts ",["$","strong",null,{"children":"Log-Structured File Systems (LFS)"}]," to better exploit persistent memory (PM). Traditional LFS writes batches of data sequentially to storage, which is great for disks but on PM (byte-addressable and with different performance characteristics) the model can be suboptimal (e.g. it might incur extra copies or poor cache usage). “Scatter Logging” likely writes data and metadata in a way that leverages PM’s fast random access – perhaps scattering small updates in place in PM while still maintaining logical log structure. It may reduce the overhead of cleaning (garbage collection) or the indirection mapping that LFS normally needs, taking advantage of PM’s persistence + low latency. Essentially, it bridges the gap by modifying how the “tail of the log” and cleaning operations work on PM, eliminating inefficiencies. ",["$","em",null,{"children":"Industry Relevance:"}]," As persistent memory technologies re-emerge (via NVMe or new NVRAM), file systems will need to adapt. Scatter Logging can ",["$","strong",null,{"children":"enable higher throughput and lower latency file operations"}]," on PM, useful for databases, caching systems, or any software using PM as storage – ensuring they aren’t constrained by algorithms designed for slow disks."]}]}]
84:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Daredevil: Rescue Your Flash Storage from Inflexible Kernel Storage Stack"}]," – ",["$","em",null,{"children":"Junzhe Li, Ran Shu, Jiayi Lin, Qingyu Zhang, Ziyue Yang, Jie Zhang, Yongqiang Xiong, Chenxiong Qian."}]," Daredevil rethinks the OS storage stack for modern SSDs. Today’s kernel I/O path has multiple layers (VFS, block layer, I/O schedulers) that were designed for much slower, simpler disks. Daredevil likely introduces a more flexible or direct I/O stack that can adapt to application needs and SSD characteristics (like parallelism and internal GC). It might provide applications more control over placement or scheduling of I/O, or bypass certain layers for efficiency, while still retaining safety. Essentially, it “rescues” performance lost in translation by offering an optimized path or an extensible interface to utilize advanced SSD features (NVMe multi-queue, Zoned Namespaces, etc.). ",["$","em",null,{"children":"Industry Relevance:"}]," With ultra-fast NVMe drives, the OS can become the bottleneck. Daredevil’s approach can ",["$","strong",null,{"children":"unlock additional IOPS and cut latency"}]," by eliminating needless overhead, benefiting databases, high-frequency trading systems, and any application running on fast storage. For cloud providers, a more efficient storage stack means they can ",["$","strong",null,{"children":"deliver more performance per drive"}]," to customers."]}]}]
85:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Solid State Drive Targeted Memory-Efficient Indexing for Universal I/O Patterns and Fragmentation Degrees"}]," – ",["$","em",null,{"children":"Junsu Im, Jeonggyun Kim, Seonggyun Oh, Jinhyung Koo, Juhyung Park, Hoon Sung Chwa, Sam H. Noh, Sungjin Lee."}]," This paper presents an indexing/data structure method designed specifically for how SSDs behave. It likely optimizes index placement and lookup considering ",["$","strong",null,{"children":"SSD characteristics"}]," like erase block sizes, write amplification, and fragmentation. The solution might adjust dynamically between different index strategies (like hash vs tree) depending on the workload’s I/O pattern (random vs sequential) and the drive’s fragmentation level. By doing so, it remains memory-efficient (small index footprint) yet offers consistently good performance across workloads. ",["$","em",null,{"children":"Industry Relevance:"}]," Filesystems and key-value stores on SSD struggle to maintain performance as fragmentation increases or workload changes. A ",["$","strong",null,{"children":"universal indexing scheme"}]," that can gracefully handle these variations means more stable latency and throughput for storage engines – relevant to any system managing data on flash, from embedded devices to large-scale storage systems."]}]}]
86:["$","strong",null,{"children":"API usage rules (specifications)"}]
87:["$","em",null,{"children":"security patches"}]
88:["$","em",null,{"children":"should"}]
89:["$","em",null,{"children":"Industry Relevance:"}]
8a:["$","strong",null,{"children":"precious documentation and automated checkers"}]
8b:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"BESA: Extending Bugs Triggered by Runtime Testing via Static Analysis"}]," – ",["$","em",null,{"children":"Jia-Ju Bai."}]," BESA is a technique to ",["$","strong",null,{"children":"amplify and generalize bugs found in testing"}]," by using static analysis. When a dynamic test (fuzz or unit test) finds a bug, BESA performs static analysis around that code to see if similar patterns exist in other contexts or along other paths, effectively finding ",["$","em",null,{"children":"extensions"}]," of the bug. For example, if a null pointer dereference was found in one function, BESA might statically trace where else that pointer could come from null and not be checked, exposing more instances. It essentially takes a concrete bug trace and uses static analysis to explore variants of it without needing further dynamic input. ",["$","em",null,{"children":"Industry Relevance:"}]," This approach helps maximize the value of each test case: QA teams and fuzzers might only hit one scenario, but BESA can ",["$","strong",null,{"children":"uncover semantically related bugs"}]," elsewhere automatically. This can increase bug-finding efficiency in large software projects (OS kernels, browsers) where once a vulnerability is seen, you want to ensure all similar vulnerabilities are found and fixed."]}]}]
8c:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"HawkSet: Automatic, Application-Agnostic, and Efficient Concurrent PM Bug Detection"}]," – ",["$","em",null,{"children":"João Oliveira, João Gonçalves, Miguel Matos."}]," HawkSet targets ",["$","strong",null,{"children":"concurrent bugs in Persistent Memory (PM) programs"}],", such as missing flushes or ordering issues that could corrupt data consistency under crashes. It likely instruments and observes a PM-enabled application (e.g., using Intel Optane with ",["$","code",null,{"children":"pmem"}]," libraries) and automatically detects anomalies like write-after-fsync or non-atomic updates. It’s application-agnostic, meaning it doesn’t need custom specifications per app – it probably uses generic patterns of correct PM usage (e.g., every persistent write should eventually be flushed) to catch bugs. And it’s efficient enough to run concurrently (possibly using parallel checking threads or core-local analysis) without huge slowdowns. ",["$","em",null,{"children":"Industry Relevance:"}]," As persistent memory finds its way into databases, file systems, and caches, ",["$","strong",null,{"children":"bugs in crash consistency can be catastrophic"}]," (data loss). HawkSet provides developers and testers a way to ",["$","strong",null,{"children":"catch PM-specific concurrency and ordering bugs"}]," automatically before deployment, increasing confidence in systems like PM databases or storage engines used by enterprises."]}]}]
8d:["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"Revealing the Unstable Foundations of eBPF-Based Kernel Extensions"}]," – ",["$","em",null,{"children":"Shawn Zhong, Jing Liu, Andrea Arpaci-Dusseau, Remzi Arpaci-Dusseau."}]," This paper analyzes the ",["$","strong",null,{"children":"fragility and pitfalls of eBPF programs"}]," running in the kernel. It likely uncovers that eBPF, despite being safer than kernel modules, rests on assumptions that can break: for instance, changes in kernel internal data structures can silently break eBPF programs, or resource exhaustion and verifier quirks can lead to instability. They might demonstrate issues like an eBPF program working on one kernel version but not another (kernel internal API instability), or difficulty debugging eBPF, or performance anomalies (e.g., jitter due to JIT). By “unstable foundations,” they highlight that eBPF’s promise of stability is not fully met due to these underlying issues. ",["$","em",null,{"children":"Industry Relevance:"}]," Many companies rely on eBPF for production monitoring and networking. This work ",["$","strong",null,{"children":"warns practitioners of hidden risks"}]," – for instance, an innocuous kernel update could break an eBPF-based firewall. It may spur improvements in eBPF tooling, better documentation of stable vs unstable hooks, and more robust BPF verifier enhancements, ultimately helping industry users maintain reliable eBPF deployments."]}]}]
23:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
1f:null
21:{"metadata":[["$","title","0",{"children":"EuroSys 2025 Paper Summaries and Analysis | 云微的胡思乱想"}],["$","meta","1",{"name":"robots","content":"index, follow"}],["$","meta","2",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","3",{"rel":"canonical","href":"https://www.yunwei37.com/blog/eurosys-2025"}],["$","link","4",{"rel":"alternate","type":"application/rss+xml","href":"https://www.yunwei37.com/feed.xml"}],["$","meta","5",{"property":"og:title","content":"EuroSys 2025 Paper Summaries and Analysis"}],["$","meta","6",{"property":"og:url","content":"https://www.yunwei37.com/blog/eurosys-2025"}],["$","meta","7",{"property":"og:site_name","content":"云微的胡思乱想"}],["$","meta","8",{"property":"og:locale","content":"en_US"}],["$","meta","9",{"property":"og:image","content":"https://www.yunwei37.com/static/images/twitter-card.png"}],["$","meta","10",{"property":"og:type","content":"article"}],["$","meta","11",{"property":"article:published_time","content":"2025-04-25T16:00:00.000Z"}],["$","meta","12",{"property":"article:modified_time","content":"2025-04-25T16:00:00.000Z"}],["$","meta","13",{"property":"article:author","content":"Yusheng Zheng (云微)"}],["$","meta","14",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","15",{"name":"twitter:title","content":"EuroSys 2025 Paper Summaries and Analysis"}],["$","meta","16",{"name":"twitter:image","content":"https://www.yunwei37.com/static/images/twitter-card.png"}]],"error":null,"digest":"$undefined"}
26:"$21:metadata"
